<!doctype html>
<html>
	<head>
	<title>CityGrid</title>

	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="edificio.js"></script>
	<script type="text/javascript" src="vertexGrid.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="Primitivas/supBarrido.js"></script>
	<script type="text/javascript" src="curvas.js"></script>
	<script type="text/javascript" src="autopista.js"></script>
	<script type="text/javascript" src="autopista_calle.js"></script>
	<script type="text/javascript" src="autopista_borde.js"></script>
	<script type="text/javascript" src="escena.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="vereda.js"></script>
	<script type="text/javascript" src="plaza.js"></script>
	<script type="text/javascript" src="Primitivas/supFan.js"></script>
	<script type="text/javascript" src="pilarAutopista.js"></script>
	<script type="text/javascript" src="Primitivas/supRevolucion.js"></script>
	<script type="text/javascript" src="luminaria.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="manzana.js"></script>
	<script type="text/javascript" src="canvas_curva.js"></script>
	<script type="text/javascript" src="auto.js"></script>
	<script type="text/javascript" src="rueda.js"></script>
	<script type="text/javascript" src="carcasaAuto.js"></script>
	<script type="text/javascript" src="skybox.js"></script>


	</head>

	<body>
	<center>

		<h1>CityGrid</h1>
		<h2>Sistemas Gr&aacute;ficos - 66.71</h2>
		<h3>Alumnas: Ana Czarnitzki y Sofia Morseletto</h3>
		<h4>Primer Cuatrimestre 2017</h4>

		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<canvas id="second-canvas" width="100" height="100">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

		<table>
		<tr><td><label for="dist_p">Distancia entre pilares:</label>
		  <input type="text" name="dist_p" id="dist_p" size="1"><br>
		<tr><td><label for="dist_f">Distancia entre faroles:</label>
		  <input type="text" name="dist_f" id="dist_f" size="1"><br>

		</table>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

	</center>

	<script id="shader-vs" type="x-shader/x-vertex">
			// Los atributos son caracter�sticas propias de cada vertice.
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
			// Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			// Los varying son propiedades que toman valor para cada fragmento a partir
			// de interpolar linealmente entre los valores que se les asigna en cada
			// v�rtice del pol�gono al cual pertenecen.
			varying highp vec4 vColor;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vColor = vec4(aVertexColor,1.0);
			}
	</script>

	<!--
	Fragment shader

	Cada pixel en un pol�gono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a
	cada pixel.
	-->
	<script id="shader-fs" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vColor;
	}
	</script>

	<!-- Vertex shader para texturas -->
	<script id="shader-texture-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec2 vTextureCoord;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vTextureCoord = aTextureCoord;
			}
	</script>

	<!--Fragment shader Texturas	-->
	<script id="shader-texture-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;

	uniform sampler2D uSampler;

	void main(void) {
		gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
	}
	</script>

	<!-- Vertex shader para texturas EDIFICIOS -->
	<script id="shader-texture-edif-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform float uAltura;

			varying vec2 vTextureCoord;

			void main(void) {
					// vec3 aux = aVertexPosition;
					// aux.y *= uAltura; //probar en y sino
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vTextureCoord = aTextureCoord;
					vTextureCoord.y *= uAltura;
			}

	</script>

	<!--Fragment shader Texturas EDIFICIOS-->
	<script id="shader-texture-edif-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;

	uniform float uAlturaPB;
	uniform float uAlturaPisos;
	uniform sampler2D uSamplerPB;
	uniform sampler2D uSamplerPisos;

	void main(void) {
		vec2 uv = vTextureCoord;
		//Agregar if de acuerdo a la textura que uso
		if(vTextureCoord.y <= uAlturaPB){
			uv.y /= uAlturaPB;
			// uv.x /= 0.25 / uAlturaPB;
			gl_FragColor = texture2D(uSamplerPB, uv);
		}else{
			uv.y -= uAlturaPB;
			uv.y /= uAlturaPisos;
			gl_FragColor = texture2D(uSamplerPisos, uv);
		}
	}
	</script>

	<!-- Vertex shader para texturas CALLES -->
	<script id="shader-texture-calle-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform float uAltura;

			varying vec2 vTextureCoord;

			void main(void) {
					// vec3 aux = aVertexPosition;
					// aux.y *= uAltura; //probar en y sino
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vTextureCoord = aTextureCoord;
					// vTextureCoord.y *= uAltura;
			}

	</script>

	<!--Fragment shader Texturas CALLES-->
	<script id="shader-texture-calle-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;

	uniform float uFinManzana;
	uniform float uFinCruce;
	uniform sampler2D uSamplerCalle;
	uniform sampler2D uSamplerCruce;

	void main(void) {
		vec2 uv = vTextureCoord;
		float k = 1.0;
		int listorti = 0;
		for(int i = 0; i >= 0; i++){
			if(vTextureCoord.y <= (uFinManzana * k + uFinCruce * (k - 1.0))){
				listorti = 1;
				uv.y -= (uFinManzana + uFinCruce) * (k - 1.0)/* - uFinCruce/6.0*/;
				uv.y /= uFinManzana;
				gl_FragColor = texture2D(uSamplerCalle, uv);
			}else if(vTextureCoord.y <= ((uFinManzana + uFinCruce) * k)){
				listorti = 1;
				uv.y -= ((uFinManzana * k) + uFinCruce * (k - 1.0));
				uv.y /= uFinCruce;
				gl_FragColor = texture2D(uSamplerCruce, uv);
			}
			k += 1.0;
			if(listorti == 1)
				break;
		}
	}
	</script>

	<!-- Vertex shader para el canvas de la curva -->
	<script id="shader-canvas-curva" type="x-shader/x-vertex">
		// Los atributos son caracter�sticas propias de cada vertice.
		attribute vec3 aVertexPosition;
		// attribute vec3 aVertexColor;

		// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada
		// v�rtice del pol�gono al cual pertenecen.
		varying highp vec4 vColor;

		void main(void) {
				// gl_Position es una variable "built-in" de GLSL que es usada para
				// almacenar la posici�n resultante del fragmento.
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColor = vec4(0.0, 0.0, 0.0, 1.0);
				gl_PointSize = 5.0;
		}
	</script>

	<!-- Fragment shader para el canvas de la curva -->
	<script id="shader-fs-canvas-curva" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	</script>

	<script>
			var gl = null,
					canvas = null,
					glProgram = null,
					fragmentShader = null,
					vertexShader = null,
					t = 0.0;
					my_grid = null;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			var mvMatrix2 = mat4.create();

			 // SHADERS FUNCTION
			function getShader(gl, id) {
					var shaderScript, src, currentChild, shader;

					// Obtenemos el elemento <script> que contiene el c�digo fuente del shader.
					shaderScript = document.getElementById(id);
					if (!shaderScript) {
							return null;
					}

					// Extraemos el contenido de texto del <script>.
					src = "";
					currentChild = shaderScript.firstChild;
					while(currentChild) {
							if (currentChild.nodeType == currentChild.TEXT_NODE) {
									src += currentChild.textContent;
							}
							currentChild = currentChild.nextSibling;
					}

					// Creamos un shader WebGL seg�n el atributo type del <script>.
					if (shaderScript.type == "x-shader/x-fragment") {
							shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
							shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
							return null;
					}

					// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
					gl.shaderSource(shader, src);

					// Compilamos el shader.
					gl.compileShader(shader);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert("An error occurred compiling the shaders: " +
									gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
			}





			//
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////


			function initWebGL()
			{
					canvas = document.getElementById("my-canvas");
					try{
							gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
					}catch(e){
					}

					if(gl)
					{
							setupWebGL();
							initShaders();
							loadTextures();
							setupBuffers();

							canvas.onmousedown = handleMouseDown;
        			document.onmouseup = handleMouseUp;
        			document.onmousemove = handleMouseMove;
        			document.onkeydown = handleKeyDownOrb;

							setInterval(drawScene, 10);
					}else{
							alert("Error: Your browser does not appear to support WebGL.");
					}
			}

			function setupWebGL()
			{
					//set the clear color
					gl.clearColor(0.7, 0.7, 0.9, 1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);
					gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

					gl.viewport(0, 0, canvas.width, canvas.height);
			}

			function initShaders()
			{
				// Obtenemos los shaders ya compilados
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				// Creamos un programa de shaders de WebGL.
				glProgram = gl.createProgram();

				// Asociamos cada shader compilado al programa.
				gl.attachShader(glProgram, vertexShader);
				gl.attachShader(glProgram, fragmentShader);

				// Linkeamos los shaders para generar el programa ejecutable.
				gl.linkProgram(glProgram);

				// Chequeamos y reportamos si hubo alg�n error.
				if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
					alert("Unable to initialize the shader program: " +
								gl.getProgramInfoLog(glProgram));
					return null;
				}

				// Depende del tipo de objeto, el programa que uso
				gl.useProgram(glProgram);

				//SHADERS DE TEXTURAS
				var fragmentShaderTexturedObj = getShader(gl, "shader-texture-fs");
			    var vertexShaderTexturedObj = getShader(gl, "shader-texture-vs");

			    shaderProgramTexturedObject = gl.createProgram();
			    gl.attachShader(shaderProgramTexturedObject, vertexShaderTexturedObj);
			    gl.attachShader(shaderProgramTexturedObject, fragmentShaderTexturedObj);
			    gl.linkProgram(shaderProgramTexturedObject);

			    if (!gl.getProgramParameter(shaderProgramTexturedObject, gl.LINK_STATUS)) {
			        alert("Could not initialise shaders");
			    }

			    gl.useProgram(shaderProgramTexturedObject);

			    shaderProgramTexturedObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexPosition");
			    gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexPositionAttribute);

			    shaderProgramTexturedObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aTextureCoord");
			    gl.enableVertexAttribArray(shaderProgramTexturedObject.textureCoordAttribute);


		        shaderProgramTexturedObject.pMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPMatrix");
		        shaderProgramTexturedObject.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uMVMatrix");
		        shaderProgramTexturedObject.samplerUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSampler");

		        //SHADERS DE TEXTURAS EDIFICIOS
				var fragmentShaderEdificio = getShader(gl, "shader-texture-edif-fs");
		        var vertexShaderEdificio = getShader(gl, "shader-texture-edif-vs");

		        shaderProgramEdificio= gl.createProgram();
		        gl.attachShader(shaderProgramEdificio, vertexShaderEdificio);
		        gl.attachShader(shaderProgramEdificio, fragmentShaderEdificio);
		        gl.linkProgram(shaderProgramEdificio);

		        if (!gl.getProgramParameter(shaderProgramEdificio, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }

		        gl.useProgram(shaderProgramEdificio);

		        shaderProgramEdificio.vertexPositionAttribute = gl.getAttribLocation(shaderProgramEdificio, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgramEdificio.vertexPositionAttribute);

		        shaderProgramEdificio.textureCoordAttribute = gl.getAttribLocation(shaderProgramEdificio, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgramEdificio.textureCoordAttribute);

		        shaderProgramEdificio.pMatrixUniform = gl.getUniformLocation(shaderProgramEdificio, "uPMatrix");
		        shaderProgramEdificio.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramEdificio, "uMVMatrix");
		        shaderProgramEdificio.samplerPB = gl.getUniformLocation(shaderProgramEdificio, "uSamplerPB");
		        shaderProgramEdificio.samplerPisos = gl.getUniformLocation(shaderProgramEdificio, "uSamplerPisos");
		        shaderProgramEdificio.Altura = gl.getUniformLocation(shaderProgramEdificio, "uAltura");
		        shaderProgramEdificio.AlturaPB = gl.getUniformLocation(shaderProgramEdificio, "uAlturaPB");
		        shaderProgramEdificio.AlturaPisos = gl.getUniformLocation(shaderProgramEdificio, "uAlturaPisos");

		        //SHADERS DE TEXTURAS CALLE
				var fragmentShaderCalle = getShader(gl, "shader-texture-calle-fs");
		        var vertexShaderCalle = getShader(gl, "shader-texture-calle-vs");

		        shaderProgramCalle = gl.createProgram();
		        gl.attachShader(shaderProgramCalle, vertexShaderCalle);
		        gl.attachShader(shaderProgramCalle, fragmentShaderCalle);
		        gl.linkProgram(shaderProgramCalle);

		        if (!gl.getProgramParameter(shaderProgramCalle, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }

		        gl.useProgram(shaderProgramCalle);

		        shaderProgramCalle.vertexPositionAttribute = gl.getAttribLocation(shaderProgramCalle, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgramCalle.vertexPositionAttribute);

		        shaderProgramCalle.textureCoordAttribute = gl.getAttribLocation(shaderProgramCalle, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgramCalle.textureCoordAttribute);

		        shaderProgramCalle.pMatrixUniform = gl.getUniformLocation(shaderProgramCalle, "uPMatrix");
		        shaderProgramCalle.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramCalle, "uMVMatrix");
		        shaderProgramCalle.samplerCalle = gl.getUniformLocation(shaderProgramCalle, "uSamplerCalle");
		        shaderProgramCalle.samplerCruce = gl.getUniformLocation(shaderProgramCalle, "uSamplerCruce");
		        shaderProgramCalle.largo = gl.getUniformLocation(shaderProgramCalle, "uAltura");
		        shaderProgramCalle.finManzana = gl.getUniformLocation(shaderProgramCalle, "uFinManzana");
		        shaderProgramCalle.finCruce = gl.getUniformLocation(shaderProgramCalle, "uFinCruce");

				gl.useProgram(glProgram);
			}

			function makeShader(src, type)
			{
					//compile the vertex shader
					var shader = gl.createShader(type);
					gl.shaderSource(shader, src);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
							alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
					}
					return shader;
			}

			var v_texturas_pisos = [];
			var v_texturas_PB = [];

			function loadTextures(){
				v_texturas_pisos.push("Texturas/ed1_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed2_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed3_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed4_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed5_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed6_fachada.jpg");
				v_texturas_pisos.push("Texturas/ed7_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed8_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed9_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed10_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed11_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed12_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed13_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed14_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed15_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed16_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed17_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed18_pisos.jpg");
				v_texturas_pisos.push("Texturas/ed19_pisos.jpg");
				v_texturas_PB.push("Texturas/ed1_pb.jpg");
				v_texturas_PB.push("Texturas/ed2_pb.jpg");
				v_texturas_PB.push("Texturas/ed3_pb.jpg");
				v_texturas_PB.push("Texturas/ed4_pb.jpg");
				v_texturas_PB.push("Texturas/ed5_pb.jpg");
				v_texturas_PB.push("Texturas/ed6_pb.jpg");
				v_texturas_PB.push("Texturas/ed7_pb.jpg");
				v_texturas_PB.push("Texturas/ed8_pb.jpg");
				v_texturas_PB.push("Texturas/ed9_pb.jpg");
				v_texturas_PB.push("Texturas/ed10_pb.jpg");
				v_texturas_PB.push("Texturas/ed11_pb.jpg");
				v_texturas_PB.push("Texturas/ed12_pb.jpg");
				v_texturas_PB.push("Texturas/ed13_pb.jpg");
				v_texturas_PB.push("Texturas/ed14_pb.jpg");
				v_texturas_PB.push("Texturas/ed15_pb.jpg");
				v_texturas_PB.push("Texturas/ed16_pb.jpg");
				v_texturas_PB.push("Texturas/ed17_pb.jpg");
				v_texturas_PB.push("Texturas/ed18_pb.jpg");
				v_texturas_PB.push("Texturas/ed19_pb.jpg");
			}

			this.handleLoadedTexture = function(texture, con_mipmap){
		        gl.bindTexture(gl.TEXTURE_2D, texture);
		        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		        if(con_mipmap){
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
			        gl.generateMipmap(gl.TEXTURE_2D);
			    }else{
			    	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
			    }

		        gl.bindTexture(gl.TEXTURE_2D, null);
			}

			var comienzo_autopista = [];

			function setupBuffers(){
					var puntos = [];
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 20.0, 0.0]);
					// puntos.push([40.0, 0.0, 0.0]);
					// puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);

					camino = new curvaBspline3();
					camino.create(puntos);
					camino.setupWebGLBuffers();

/*					calle = new Calle();
					calle.create_perfil(5.0, 0.5);
					calle.create_calle_escena(35.0, [0.0, 0.0, 35.0], 2.0);
					// calle.initTexture("Texturas/tramo-dobleamarilla.jpg");
					calle.initTexture("Texturas/uv_grid2.jpg");
					calle.initTexture("Texturas/cruce.jpg");
					calle.setupWebGLBuffers();
					calle.debug_shader();
					*/

/*					edif = new Edificio();
					edif.create(10, 20, 10, [0, 0, 0], [0, 0, 0], 350.0);
					edif.initTexture("ed12_pb.jpg");
					edif.initTexture("ed1_pisos.jpg");
					edif.setupWebGLBuffers();*/

					escena = new Escena();
					escena.initTextures();

					//Cant manzanas, lado manzana, ancho calle
					escena.create_manzanas(6.0, 5.0, 1.0);
					escena.ubicar_autopista(puntos, 20, 10);
					escena.create_calles();
					escena.create_mapa();
					escena.create_autos();

					escena.setupWebGLBuffers();

					comienzo_autopista = escena.autopista.get_comienzo();

					vec3.multiply(comienzo_autopista, comienzo_autopista, [1, -1, 1]);
					vec3.add(comienzo_autopista, comienzo_autopista, [0, -6, 0]);
					free_camera_au.pos = comienzo_autopista;
			}

		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

			//Para manejar los eventos del mouse
		    var mouseDown = false;
		    var lastMouseX = null;
		    var lastMouseY = null;
		    var lastMouseX2 = null;
		    var lastMouseY2 = null;

		    var escenaRotationMatrix = mat4.create();
		    mat4.identity(escenaRotationMatrix);
		    var zoomMatrix = mat4.create();
		    mat4.identity(zoomMatrix);

		    var cameraMatrixAu = mat4.create();
		    mat4.identity(cameraMatrixAu);
		    var cameraMatrixSt = mat4.create();
		    mat4.identity(cameraMatrixSt);

		    var free_camera_au = {
		    	pos: [0.0, 0.0, 0.0],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2
		    }
		    var free_camera_st = {
		    	pos: [0.0, -1.0, -17.5],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2
		    }

		    var cant_C = 0;

		    function handleMouseDown(event) {
		        mouseDown = true;
		        lastMouseX = event.clientX;
		        lastMouseY = event.clientY;
		        lastMouseX2 = event.clientX;
		        lastMouseY2 = event.clientY;
		    }


		    function handleMouseUp(event) {
		        mouseDown = false;
		    }

	        function handleKeyDownFreeStreet(event){
	        	//Uso coordenadas esfericas
	        	switch(event.keyCode){
	        		case 87:{ // 87 es la "w"

	        			//Modifico ambas coordenadas pq se tiene que mover en el sentido en el
	        			//que mira
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 83:{ //83 es "s"
						handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
						handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 65:{ // 65 es "a"
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 68:{ // 68 es "d"
	        			handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 67:
	        			handleCams();
		    			break;
	        	}
	        	actualizar_CameraMatrix(handleKeyDownFreeStreet.camera, handleKeyDownFreeStreet.mat);
	        }

	        function handleMouseMoveFreeStreet(event){
	        	if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX2;
		        var deltaY = newY - lastMouseY2;

				handleMouseMoveFreeStreet.camera.phi += deltaX * 0.01;
				handleMouseMoveFreeStreet.camera.theta += deltaY * 0.01;

				if(handleMouseMoveFreeStreet.camera.theta > Math.PI)
					handleMouseMoveFreeStreet.camera.theta = Math.PI;

				if(handleMouseMoveFreeStreet.camera.theta < 0)
					handleMouseMoveFreeStreet.camera.theta = 0;

		        lastMouseX2 = newX;
		        lastMouseY2 = newY;

		        actualizar_CameraMatrix(handleMouseMoveFreeStreet.camera, handleMouseMoveFreeStreet.mat);
	        }

		    function handleMouseMove(event) {
		        if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX
		        var newRotationMatrix = mat4.create();
		        mat4.identity(newRotationMatrix);
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

		        var deltaY = newY - lastMouseY;
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

		        mat4.multiply(escenaRotationMatrix, newRotationMatrix, escenaRotationMatrix);

		        lastMouseX = newX
		        lastMouseY = newY;
		    }

		    function handleKeyDownOrb(event) {
		    	switch(event.keyCode){
		    		case 171: //+
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, 10.0]);
		    			break;
		    		case 173: // -
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, -10.0]);
		    			break;
		    		case 67: // c
		    			handleCams();
		    			break;
		    	}
		    }

		    function actualizar_CameraMatrix(free_camera, cameraMatrix){
		    	mat4.identity(cameraMatrix);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.theta - Math.PI/2, [1.0, 0.0, 0.0]);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.phi, [0.0, 1.0, 0.0]);

		    	mat4.translate(cameraMatrix, cameraMatrix, free_camera.pos);
		    }

		    function handleCams(){
		    	primero = 0;
	    		if(cant_C == 0){

	    			actualizar_CameraMatrix(free_camera_st, cameraMatrixSt);

	    			handleMouseMoveFreeStreet.camera = free_camera_st;
	    			handleKeyDownFreeStreet.camera = free_camera_st;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixSt;
	    			handleKeyDownFreeStreet.mat = cameraMatrixSt;

	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;

	    			cant_C++;

	    		}else if(cant_C == 1){

	    			actualizar_CameraMatrix(free_camera_au, cameraMatrixAu);

	    			handleMouseMoveFreeStreet.camera = free_camera_au;
	    			handleKeyDownFreeStreet.camera = free_camera_au;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixAu;
	    			handleKeyDownFreeStreet.mat = cameraMatrixAu;
	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;
	    			cant_C++;
	    		}else if(cant_C == 2){
	    			document.onmousemove = handleMouseMove;
	    			document.onkeydown = handleKeyDownOrb;
	    			cant_C = 0;
	    		}
		    }

		    var primero = 1;

			function drawScene(){
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				// Preparamos una matriz de perspectiva.
				mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 200.0);
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

				// PARA SHADER TEXTURAS
				gl.useProgram(shaderProgramTexturedObject);
				gl.uniformMatrix4fv(shaderProgramTexturedObject.pMatrixUniform, false, pMatrix);
				//------------------------
				// PARA SHADER EDIFICIO
				gl.useProgram(shaderProgramEdificio);
				gl.uniformMatrix4fv(shaderProgramEdificio.pMatrixUniform, false, pMatrix);
				//------------------------
				// PARA SHADER CALLE
				gl.useProgram(shaderProgramCalle);
				gl.uniformMatrix4fv(shaderProgramCalle.pMatrixUniform, false, pMatrix);
				gl.useProgram(glProgram);
				//------------------------

				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
				// Preparamos una matriz de modelo+vista.
				mat4.identity(mvMatrix);

				if((cant_C == 0) || (primero == 1)){
					mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);
					mat4.multiply(mvMatrix, mvMatrix, zoomMatrix);
					mat4.multiply(mvMatrix, mvMatrix, escenaRotationMatrix);
					//Traslado ancho y alto ciudad
					mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				}else if(cant_C == 1){
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixSt);
				}else{
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixAu);

				}

				// mat4.rotate(mvMatrix, mvMatrix, t, [1.0, 0.0, 0.0]);
				t = t + 0.1;

				gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

				//PARA SHADER TEXTURAS
				gl.useProgram(shaderProgramTexturedObject);
				gl.uniformMatrix4fv(shaderProgramTexturedObject.ModelViewMatrixUniform, false, mvMatrix);
				//--------------------------------
				//PARA SHADER EDIFICIO
				gl.useProgram(shaderProgramEdificio);
				gl.uniformMatrix4fv(shaderProgramEdificio.ModelViewMatrixUniform, false, mvMatrix);
				//---------------
				//PARA SHADER CALLE
				gl.useProgram(shaderProgramCalle);
				gl.uniformMatrix4fv(shaderProgramCalle.ModelViewMatrixUniform, false, mvMatrix);
				gl.useProgram(glProgram);
				//---------------

				//cuadrado.draw();
				// camino.draw();
				// ruta.draw();
/*				edif.tick(t);
				edif.draw(mvMatrix);*/
				escena.tick(t);
				escena.draw(mvMatrix);
				// calle.drawCalle(mvMatrix, 35.0, 2.0, 5.0);

			}

			function main(){
				initWebGL();
				init_canvas_curva();
			}

	window.onload=main();
	</script>

</body>
</html>
