<!doctype html>
<html>
	<head>
	<title>CityGrid</title>

	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="edificio.js"></script>
	<script type="text/javascript" src="vertexGrid.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="Primitivas/supBarrido.js"></script>
	<script type="text/javascript" src="curvas.js"></script>
	<script type="text/javascript" src="autopista.js"></script>
	<script type="text/javascript" src="autopista_calle.js"></script>
	<script type="text/javascript" src="autopista_borde.js"></script>
	<script type="text/javascript" src="escena.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="vereda.js"></script>
	<script type="text/javascript" src="plaza.js"></script>
	<script type="text/javascript" src="Primitivas/supFan.js"></script>
	<script type="text/javascript" src="pilarAutopista.js"></script>
	<script type="text/javascript" src="Primitivas/supRevolucion.js"></script>
	<script type="text/javascript" src="luminaria.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="manzana.js"></script>
	<script type="text/javascript" src="canvas_curva.js"></script>


	</head>

	<body>
	<center>

		<h1>CityGrid</h1>
		<h2>Sistemas Gr&aacute;ficos - 66.71</h2>
		<h3>Alumnos</h3>
		<h4>Primer Cuatrimestre 2017</h4>

		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<canvas id="second-canvas" width="100" height="100">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

	</center>

	<script id="shader-vs" type="x-shader/x-vertex">
			// Los atributos son caracter�sticas propias de cada vertice.
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
			// Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			// Los varying son propiedades que toman valor para cada fragmento a partir
			// de interpolar linealmente entre los valores que se les asigna en cada
			// v�rtice del pol�gono al cual pertenecen.
			varying highp vec4 vColor;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vColor = vec4(aVertexColor,1.0);
			}
	</script>

	<!--
	Fragment shader

	Cada pixel en un pol�gono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a
	cada pixel.
	-->
	<script id="shader-fs" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vColor;
	}
	</script>

	<!-- Vertex shader para el canvas de la curva -->
	<script id="shader-canvas-curva" type="x-shader/x-vertex">
		// Los atributos son caracter�sticas propias de cada vertice.
		attribute vec3 aVertexPosition;
		// attribute vec3 aVertexColor;

		// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada
		// v�rtice del pol�gono al cual pertenecen.
		varying highp vec4 vColor;

		void main(void) {
				// gl_Position es una variable "built-in" de GLSL que es usada para
				// almacenar la posici�n resultante del fragmento.
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColor = vec4(0.0, 0.0, 0.0, 1.0);
				gl_PointSize = 5.0;
		}
	</script>

	<!-- Fragment shader para el canvas de la curva -->
	<script id="shader-fs-canvas-curva" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	</script>

	<script>
			var gl = null,
					canvas = null,
					glProgram = null,
					fragmentShader = null,
					vertexShader = null,
					t = 0.0;
					my_grid = null;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();


			 // SHADERS FUNCTION
			function getShader(gl, id) {
					var shaderScript, src, currentChild, shader;

					// Obtenemos el elemento <script> que contiene el c�digo fuente del shader.
					shaderScript = document.getElementById(id);
					if (!shaderScript) {
							return null;
					}

					// Extraemos el contenido de texto del <script>.
					src = "";
					currentChild = shaderScript.firstChild;
					while(currentChild) {
							if (currentChild.nodeType == currentChild.TEXT_NODE) {
									src += currentChild.textContent;
							}
							currentChild = currentChild.nextSibling;
					}

					// Creamos un shader WebGL seg�n el atributo type del <script>.
					if (shaderScript.type == "x-shader/x-fragment") {
							shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
							shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
							return null;
					}

					// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
					gl.shaderSource(shader, src);

					// Compilamos el shader.
					gl.compileShader(shader);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert("An error occurred compiling the shaders: " +
									gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
			}





			//
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////


			function initWebGL()
			{
					canvas = document.getElementById("my-canvas");
					try{
							gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
					}catch(e){
					}

					if(gl)
					{
							setupWebGL();
							initShaders();
							setupBuffers();

							canvas.onmousedown = handleMouseDown;
        					document.onmouseup = handleMouseUp;
        					document.onmousemove = handleMouseMove;

							setInterval(drawScene, 10);
					}else{
							alert("Error: Your browser does not appear to support WebGL.");
					}
			}

			function setupWebGL()
			{
					//set the clear color
					gl.clearColor(0.1, 0.1, 0.2, 1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);
					gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

					gl.viewport(0, 0, canvas.width, canvas.height);
			}

			function initShaders()
			{
					// Obtenemos los shaders ya compilados
					var fragmentShader = getShader(gl, "shader-fs");
					var vertexShader = getShader(gl, "shader-vs");

					// Creamos un programa de shaders de WebGL.
					glProgram = gl.createProgram();

					// Asociamos cada shader compilado al programa.
					gl.attachShader(glProgram, vertexShader);
					gl.attachShader(glProgram, fragmentShader);

					// Linkeamos los shaders para generar el programa ejecutable.
					gl.linkProgram(glProgram);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
						alert("Unable to initialize the shader program: " +
									gl.getProgramInfoLog(glProgram));
						return null;
					}

					// Le decimos a WebGL que de aqu� en adelante use el programa generado.
					gl.useProgram(glProgram);
			}

			function makeShader(src, type)
			{
					//compile the vertex shader
					var shader = gl.createShader(type);
					gl.shaderSource(shader, src);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
							alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
					}
					return shader;
			}

			function setupBuffers(){
/*					cuadrado = new Edificio();
					cuadrado.create(2,2,1.5);
					cuadrado.setupWebGLBuffers();*/
					var puntos = [];
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 0.0, 0.0]);
					puntos.push([40.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);

/*					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 0.0, 0.0]);
					puntos.push([40.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([80.0, 0.0, 0.0]);
					puntos.push([80.0, 0.0, 0.0]);
					puntos.push([80.0, 0.0, 0.0]);
					puntos.push([80.0, 0.0, 0.0]);
					puntos.push([100.0, 0.0, 0.0]);
					puntos.push([100.0, 0.0, 0.0]);
					puntos.push([100.0, 0.0, 0.0]);
					puntos.push([100.0, 0.0, 0.0]);*/

/*					camino = new curvaBspline3();
					camino.create(puntos);
					//camino.curva_prueba();
					camino.setupWebGLBuffers();

					ruta = new Autopista();
					ruta.create(camino, 10, 10);*/
					escena = new Escena();					
					
					escena.create_manzanas(23.0, 4.0, 5.0, 1.0);
					escena.ubicar_autopista(puntos, 10, 10);
					escena.create_calles();
					escena.create_mapa();

					pilar = new PilarAutopista();
					pilar.create();
					pilar.scale(0.1,0.1,0.1);

/*					plaza = new Plaza();
					plaza.create(4.0, 0.5);
					plaza.setupWebGLBuffers();*/
			}

		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

			//Para manejar los eventos del mouse			
		    var mouseDown = false;
		    var lastMouseX = null;
		    var lastMouseY = null;

		    var escenaRotationMatrix = mat4.create();
		    mat4.identity(escenaRotationMatrix);

		    function handleMouseDown(event) {
		        mouseDown = true;
		        lastMouseX = event.clientX;
		        lastMouseY = event.clientY;
		    }


		    function handleMouseUp(event) {
		        mouseDown = false;
		    }


		    function handleMouseMove(event) {
		        if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX
		        var newRotationMatrix = mat4.create();
		        mat4.identity(newRotationMatrix);
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

		        var deltaY = newY - lastMouseY;
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

		        mat4.multiply(escenaRotationMatrix, newRotationMatrix, escenaRotationMatrix);

		        lastMouseX = newX
		        lastMouseY = newY;
		    }

			function drawScene(){
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				// Preparamos una matriz de perspectiva.
				mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 200.0);
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
				// Preparamos una matriz de modelo+vista.
				mat4.identity(mvMatrix);
				mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);

				mat4.multiply(mvMatrix, mvMatrix, escenaRotationMatrix);
				//Traslado ancho ciudad / 2 
				mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				// mat4.rotate(mvMatrix, mvMatrix, t, [1.0, 0.0, 0.0]);
				// t = t + 0.1;

				gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

				//cuadrado.draw();
				// camino.draw();
				// ruta.draw();
				escena.draw();
				// plaza.draw();
				// pilar.draw();

			}

			function main(){
				initWebGL();
				init_canvas_curva();
			}

	window.onload=main();
	</script>

</body>
</html>
