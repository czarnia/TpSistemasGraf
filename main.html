<!doctype html>
<html>
	<head>
	<title>CityGrid</title>

	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="edificio.js"></script>
	<script type="text/javascript" src="vertexGrid.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="Primitivas/supBarrido.js"></script>
	<script type="text/javascript" src="curvas.js"></script>
	<script type="text/javascript" src="autopista.js"></script>
	<script type="text/javascript" src="autopista_calle.js"></script>
	<script type="text/javascript" src="autopista_borde.js"></script>
	<script type="text/javascript" src="escena.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="vereda.js"></script>
	<script type="text/javascript" src="plaza.js"></script>
	<script type="text/javascript" src="Primitivas/supFan.js"></script>
	<script type="text/javascript" src="pilarAutopista.js"></script>
	<script type="text/javascript" src="Primitivas/supRevolucion.js"></script>
	<script type="text/javascript" src="luminaria.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="manzana.js"></script>
	<script type="text/javascript" src="canvas_curva.js"></script>
	<script type="text/javascript" src="auto.js"></script>
	<script type="text/javascript" src="rueda.js"></script>
	<script type="text/javascript" src="carcasaAuto.js"></script>


	</head>

	<body>
	<center>

		<h1>CityGrid</h1>
		<h2>Sistemas Gr&aacute;ficos - 66.71</h2>
		<h3>Alumnos</h3>
		<h4>Primer Cuatrimestre 2017</h4>

		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<canvas id="second-canvas" width="100" height="100">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

		<table>
		<tr><td><label for="dist_p">Distancia entre pilares:</label>
		  <input type="text" name="dist_p" id="dist_p" size="1"><br>
		<tr><td><label for="dist_f">Distancia entre faroles:</label>
		  <input type="text" name="dist_f" id="dist_f" size="1"><br>

		</table>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

	</center>

	<script id="shader-vs" type="x-shader/x-vertex">
			// Los atributos son caracter�sticas propias de cada vertice.
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
			// Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			// Los varying son propiedades que toman valor para cada fragmento a partir
			// de interpolar linealmente entre los valores que se les asigna en cada
			// v�rtice del pol�gono al cual pertenecen.
			varying highp vec4 vColor;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vColor = vec4(aVertexColor,1.0);
			}
	</script>

	<!--
	Fragment shader

	Cada pixel en un pol�gono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a
	cada pixel.
	-->
	<script id="shader-fs" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vColor;
	}
	</script>

	<!-- Vertex shader para el canvas de la curva -->
	<script id="shader-canvas-curva" type="x-shader/x-vertex">
		// Los atributos son caracter�sticas propias de cada vertice.
		attribute vec3 aVertexPosition;
		// attribute vec3 aVertexColor;

		// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada
		// v�rtice del pol�gono al cual pertenecen.
		varying highp vec4 vColor;

		void main(void) {
				// gl_Position es una variable "built-in" de GLSL que es usada para
				// almacenar la posici�n resultante del fragmento.
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColor = vec4(0.0, 0.0, 0.0, 1.0);
				gl_PointSize = 5.0;
		}
	</script>

	<!-- Fragment shader para el canvas de la curva -->
	<script id="shader-fs-canvas-curva" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	</script>

	<script>
			var gl = null,
					canvas = null,
					glProgram = null,
					fragmentShader = null,
					vertexShader = null,
					t = 0.0;
					my_grid = null;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();


			 // SHADERS FUNCTION
			function getShader(gl, id) {
					var shaderScript, src, currentChild, shader;

					// Obtenemos el elemento <script> que contiene el c�digo fuente del shader.
					shaderScript = document.getElementById(id);
					if (!shaderScript) {
							return null;
					}

					// Extraemos el contenido de texto del <script>.
					src = "";
					currentChild = shaderScript.firstChild;
					while(currentChild) {
							if (currentChild.nodeType == currentChild.TEXT_NODE) {
									src += currentChild.textContent;
							}
							currentChild = currentChild.nextSibling;
					}

					// Creamos un shader WebGL seg�n el atributo type del <script>.
					if (shaderScript.type == "x-shader/x-fragment") {
							shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
							shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
							return null;
					}

					// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
					gl.shaderSource(shader, src);

					// Compilamos el shader.
					gl.compileShader(shader);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert("An error occurred compiling the shaders: " +
									gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
			}





			//
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////


			function initWebGL()
			{
					canvas = document.getElementById("my-canvas");
					try{
							gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
					}catch(e){
					}

					if(gl)
					{
							setupWebGL();
							initShaders();
							setupBuffers();

							canvas.onmousedown = handleMouseDown;
        					document.onmouseup = handleMouseUp;
        					document.onmousemove = handleMouseMove;
        					document.onkeydown = handleKeyDownOrb;

							setInterval(drawScene, 10);
					}else{
							alert("Error: Your browser does not appear to support WebGL.");
					}
			}

			function setupWebGL()
			{
					//set the clear color
					gl.clearColor(0.7, 0.7, 0.9, 1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);
					gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

					gl.viewport(0, 0, canvas.width, canvas.height);
			}

			function initShaders()
			{
					// Obtenemos los shaders ya compilados
					var fragmentShader = getShader(gl, "shader-fs");
					var vertexShader = getShader(gl, "shader-vs");

					// Creamos un programa de shaders de WebGL.
					glProgram = gl.createProgram();

					// Asociamos cada shader compilado al programa.
					gl.attachShader(glProgram, vertexShader);
					gl.attachShader(glProgram, fragmentShader);

					// Linkeamos los shaders para generar el programa ejecutable.
					gl.linkProgram(glProgram);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
						alert("Unable to initialize the shader program: " +
									gl.getProgramInfoLog(glProgram));
						return null;
					}

					// Le decimos a WebGL que de aqu� en adelante use el programa generado.
					gl.useProgram(glProgram);
			}

			function makeShader(src, type)
			{
					//compile the vertex shader
					var shader = gl.createShader(type);
					gl.shaderSource(shader, src);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
							alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
					}
					return shader;
			}

			var comienzo_autopista = [];

			function setupBuffers(){					
/*					cuadrado = new Edificio();
					cuadrado.create(2,2,1.5);
					cuadrado.setupWebGLBuffers();*/
					var puntos = [];
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 20.0, 0.0]);
					// puntos.push([40.0, 0.0, 0.0]);
					// puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);

					escena = new Escena();

					//Cant manzanas, lado manzana, ancho calle
					escena.create_manzanas(6.0, 5.0, 1.0);
					escena.ubicar_autopista(puntos, 20, 10);
					escena.create_calles();
					escena.create_mapa();
					escena.create_autos();
					comienzo_autopista = escena.autopista.get_comienzo();
					console.log("Comienzo autopista: ", comienzo_autopista);
					vec3.multiply(comienzo_autopista, comienzo_autopista, [1, -1, 1]);
					vec3.add(comienzo_autopista, comienzo_autopista, [0, -6, 0]);
					free_camera_au.pos = comienzo_autopista;
					console.log("Pos camara: ", free_camera_au.pos);
			}

		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

			//Para manejar los eventos del mouse
		    var mouseDown = false;
		    var lastMouseX = null;
		    var lastMouseY = null;
		    var lastMouseX2 = null;
		    var lastMouseY2 = null;

		    var escenaRotationMatrix = mat4.create();
		    mat4.identity(escenaRotationMatrix);
		    var zoomMatrix = mat4.create();
		    mat4.identity(zoomMatrix);
		    var cameraMatrixAu = mat4.create();
		    mat4.identity(cameraMatrixAu);
		    var cameraMatrixSt = mat4.create();
		    mat4.identity(cameraMatrixSt);
		    
		    var free_camera_au = {
		    	pos: [0.0, 0.0, 0.0],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2
		    }
		    var free_camera_st = {
		    	pos: [0.0, -10.0, -20.0],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2		    	
		    }

		    var cant_C = 0;

		    function handleMouseDown(event) {
		        mouseDown = true;
		        lastMouseX = event.clientX;
		        lastMouseY = event.clientY;
		        lastMouseX2 = event.clientX;
		        lastMouseY2 = event.clientY;
		    }


		    function handleMouseUp(event) {
		        mouseDown = false;
		    }

	        function handleKeyDownFreeStreet(event){
	        	//Uso coordenadas esfericas
	        	switch(event.keyCode){
	        		case 87:{ // 87 es la "w"
	        			//Modifico ambas coordenadas pq se tiene que mover en el sentido en el 
	        			//que mira
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 83:{ //83 es "s"
						handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
						handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 65:{ // 65 es "a"
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 68:{ // 68 es "d"
	        			handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 67:
	        			handleCams();
		    			break;
	        	}
	        	actualizar_CameraMatrix(handleKeyDownFreeStreet.camera, handleKeyDownFreeStreet.mat);
	        }

	        function handleMouseMoveFreeStreet(event){
	        	if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX2;
		        var deltaY = newY - lastMouseY2;

				handleMouseMoveFreeStreet.camera.phi += deltaX * 0.01;
				handleMouseMoveFreeStreet.camera.theta += deltaY * 0.01;

				if(handleMouseMoveFreeStreet.camera.theta > Math.PI)
					handleMouseMoveFreeStreet.camera.theta = Math.PI;

				if(handleMouseMoveFreeStreet.camera.theta < 0)
					handleMouseMoveFreeStreet.camera.theta = 0;

		        lastMouseX2 = newX;
		        lastMouseY2 = newY;

		        actualizar_CameraMatrix(handleMouseMoveFreeStreet.camera, handleMouseMoveFreeStreet.mat);
	        }

		    function handleMouseMove(event) {
		        if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX
		        var newRotationMatrix = mat4.create();
		        mat4.identity(newRotationMatrix);
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

		        var deltaY = newY - lastMouseY;
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

		        mat4.multiply(escenaRotationMatrix, newRotationMatrix, escenaRotationMatrix);

		        lastMouseX = newX
		        lastMouseY = newY;
		    }

		    function handleKeyDownOrb(event) {
		    	switch(event.keyCode){
		    		case 171: //+
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, 10.0]);
		    			break;
		    		case 173: // -
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, -10.0]);
		    			break;
		    		case 67: // c
		    			handleCams();
		    			break;
		    	}
		    }

		    function actualizar_CameraMatrix(free_camera, cameraMatrix){
		    	mat4.identity(cameraMatrix);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.theta - Math.PI/2, [1.0, 0.0, 0.0]);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.phi, [0.0, 1.0, 0.0]);
		    	
		    	mat4.translate(cameraMatrix, cameraMatrix, free_camera.pos);
		    }

		    function handleCams(){
		    	primero = 0;
	    		if(cant_C == 0){
	    			actualizar_CameraMatrix(free_camera_st, cameraMatrixSt);

	    			handleMouseMoveFreeStreet.camera = free_camera_st;
	    			handleKeyDownFreeStreet.camera = free_camera_st;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixSt;
	    			handleKeyDownFreeStreet.mat = cameraMatrixSt;
	    			
	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;
	    			cant_C++;
    				
	    		}else if(cant_C == 1){
	    			actualizar_CameraMatrix(free_camera_au, cameraMatrixAu);

	    			handleMouseMoveFreeStreet.camera = free_camera_au;
	    			handleKeyDownFreeStreet.camera = free_camera_au;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixAu;
	    			handleKeyDownFreeStreet.mat = cameraMatrixAu;
	    			
	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;
	    			cant_C++;
	    		}else if(cant_C == 2){
	    			document.onmousemove = handleMouseMove;
	    			document.onkeydown = handleKeyDownOrb;
	    			cant_C = 0;
	    		}
		    }

		    var primero = 1;

			function drawScene(){
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				// Preparamos una matriz de perspectiva.
				mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 200.0);
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
				// Preparamos una matriz de modelo+vista.
				mat4.identity(mvMatrix);
				// mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);

				if((cant_C == 0) || (primero == 1)){
					mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);
					mat4.multiply(mvMatrix, mvMatrix, zoomMatrix);
					mat4.multiply(mvMatrix, mvMatrix, escenaRotationMatrix);
					mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				}else if(cant_C == 1){
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixSt);
				}else{
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixAu);
				}
				
				//Traslado ancho y alto ciudad
				// mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				// mat4.rotate(mvMatrix, mvMatrix, t, [1.0, 0.0, 0.0]);
				t = t + 0.1;

				gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

				//cuadrado.draw();
				// camino.draw();
				// ruta.draw();

				escena.tick(t);
				escena.draw(mvMatrix);

				// plaza.draw();
				// pilar.draw();

			}

			function main(){
				initWebGL();
				init_canvas_curva();
			}

	window.onload=main();
	</script>

</body>
</html>
