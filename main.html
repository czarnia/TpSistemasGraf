<!doctype html>
<html>
	<head>
	<title>CityGrid</title>

	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="edificio.js"></script>
	<script type="text/javascript" src="vertexGrid.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="Primitivas/supBarrido.js"></script>
	<script type="text/javascript" src="curvas.js"></script>
	<script type="text/javascript" src="autopista.js"></script>
	<script type="text/javascript" src="autopista_calle.js"></script>
	<script type="text/javascript" src="autopista_borde.js"></script>
	<script type="text/javascript" src="escena.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="vereda.js"></script>
	<script type="text/javascript" src="plaza.js"></script>
	<script type="text/javascript" src="Primitivas/supFan.js"></script>
	<script type="text/javascript" src="pilarAutopista.js"></script>
	<script type="text/javascript" src="Primitivas/supRevolucion.js"></script>
	<script type="text/javascript" src="luminaria.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="manzana.js"></script>
	<script type="text/javascript" src="canvas_curva.js"></script>
	<script type="text/javascript" src="auto.js"></script>
	<script type="text/javascript" src="rueda.js"></script>
	<script type="text/javascript" src="carcasaAuto.js"></script>
	<script type="text/javascript" src="skybox.js"></script>


	</head>

	<body>
	<center>

		<h1>CityGrid</h1>
		<h2>Sistemas Gr&aacute;ficos - 66.71</h2>
		<h3>Alumnas: Ana Czarnitzki y Sofia Morseletto</h3>
		<h4>Primer Cuatrimestre 2017</h4>

		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<canvas id="second-canvas" width="100" height="100">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

		<table>
		<tr><td><label for="dist_p">Distancia entre pilares:</label>
		  <input type="text" name="dist_p" id="dist_p" size="1"><br>
		<tr><td><label for="dist_f">Distancia entre faroles:</label>
		  <input type="text" name="dist_f" id="dist_f" size="1"><br>

		</table>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

	</center>

	<script id="shader-vs" type="x-shader/x-vertex">
			// Los atributos son caracter�sticas propias de cada vertice.
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
			// Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			// Los varying son propiedades que toman valor para cada fragmento a partir
			// de interpolar linealmente entre los valores que se les asigna en cada
			// v�rtice del pol�gono al cual pertenecen.
			varying highp vec4 vColor;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vColor = vec4(aVertexColor,1.0);
			}
	</script>

	<!--
	Fragment shader

	Cada pixel en un pol�gono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a
	cada pixel.
	-->
	<script id="shader-fs" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vColor;
	}
	</script>

	<!-- Vertex shader para texturas -->
	<script id="shader-texture-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			// uniform bool uUseNormalMap;

			varying vec2 vTextureCoord;
			// varying vec3 vLightWeighting;
			varying vec3 vVertexNormal;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;

			void main(void) {
					vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
					gl_Position = uPMatrix * vPosition;
					vTextureCoord = aTextureCoord;
					vVertexNormal = aVertexNormal;
			        vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			}
	</script>

	<!--Fragment shader Texturas	-->
	<script id="shader-texture-fs" type="x-shader/x-fragment">
		precision mediump float;
		uniform vec3 uAmbientColor;
		uniform bool uUseLighting;
		//uniform bool uUseNormalMap;

		uniform vec3 uLightingDirection;
		uniform vec3 uDirectionalColor;
		uniform vec3 uPointLightingLocation[10];
		uniform vec3 uPointLightingColor;

		varying vec2 vTextureCoord;
		// varying vec3 vLightWeighting;
		varying vec3 vVertexNormal;
		varying vec4 vPosition;

		varying vec3 vTransformedNormal;
		//varying vec3 vTransformedTangent;

		uniform sampler2D uSampler;
		//uniform sampler2D uSamplerMap;

		void main(void) {
			vec3 lightWeighting;
			vec3 normal = normalize(vTransformedNormal);
			//vec3 tangent = normalize(vTransformedTangent);

			if (!uUseLighting) {
				    lightWeighting = vec3(0.8, 0.7, 0.4);
			} else {
				//************LUZ DIRECCIONAL****************
				float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
				// lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;

				lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;

				//************LUZ PUNTUAL****************
				for(int i = 0; i < 10; i++){
					float distancia = distance(vPosition.xyz, uPointLightingLocation[i]);
					if(distancia < 10.0){
						vec3 lightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);
						float directionalPointLightWeighting = max(dot(normalize(normal), lightDirection), 0.0);
						directionalPointLightWeighting *= 5.0/(distancia*distancia);
						lightWeighting += uPointLightingColor * directionalPointLightWeighting;
					}
				}
			}

			vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
			gl_FragColor = vec4(textureColor.rgb * lightWeighting, textureColor.a);
			//gl_FragColor = vec4(transformedNormal.rgb, 1.0);
			 //gl_FragColor = vec4(vVertexNormal.rgb*2.0-1.0, 1.0);
		}
	</script>

	<!-- Vertex shader para NORMAL MAP -->
	<script id="shader-normal-map-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;
			attribute vec3 aVertexTangent;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			// uniform bool uUseNormalMap;

			varying vec2 vTextureCoord;
			// varying vec3 vLightWeighting;
			varying vec3 vVertexNormal;
			varying vec3 vTransformedNormal;
			varying vec4 vPosition;
			varying vec3 vVertexTangent;

			void main(void) {
					vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
					gl_Position = uPMatrix * vPosition;
					vTextureCoord = aTextureCoord;
					vVertexNormal = aVertexNormal;
			        vTransformedNormal = normalize(uNMatrix * aVertexNormal);
			        vVertexTangent = aVertexTangent;
			}
	</script>

	<!--Fragment shader NORMAL MAP	-->
	<script id="shader-normal-map-fs" type="x-shader/x-fragment">
		precision mediump float;
		uniform vec3 uAmbientColor;
		uniform bool uUseLighting;
		uniform bool uUseNormalMap;

		uniform vec3 uLightingDirection;
		uniform vec3 uDirectionalColor;
		uniform vec3 uPointLightingLocation[10];
		uniform vec3 uPointLightingColor;

		varying vec2 vTextureCoord;
		// varying vec3 vLightWeighting;
		varying vec3 vVertexNormal;
		varying vec4 vPosition;

		varying vec3 vTransformedNormal;
		varying vec3 vVertexTangent;

		uniform sampler2D uSampler;
		uniform sampler2D uSamplerMap;

		// Funcion transponer auxiliar
		mat3 transpose(mat3 m) {
			mat3 aux = mat3(0.0);
			aux[0][0] = m[0][0];
			aux[1][1] = m[1][1];
			aux[2][2] = m[2][2];

			aux[0][1] = m[1][0];
			aux[1][0] = m[0][1];

			aux[0][2] = m[2][0];
			aux[2][0] = m[0][2];

			aux[1][2] = m[2][1];
			aux[2][1] = m[1][2];
			return aux;
		}

		void main(void) {
			vec3 lightWeighting;
			vec3 normal = normalize(vTransformedNormal);
			vec3 tangent = normalize(vVertexTangent);

			if (!uUseLighting) {
				    lightWeighting = vec3(0.8, 0.7, 0.4);
			} else {
				//************LUZ DIRECCIONAL****************
				vec3 lightDirection = uLightingDirection;
				float directionalLightWeighting;
				if (uUseNormalMap){
					vec4 normalMap = texture2D(uSamplerMap, vec2(vTextureCoord.s, vTextureCoord.t));
					normalMap = normalMap * 2.0 - vec4(1.0, 1.0, 1.0, 1.0);

					vec3 binormal = normalize(cross(normal, tangent));
					mat3 base_p = transpose(mat3(tangent, binormal, normal));

					lightDirection = base_p * lightDirection;
					// uLightingDirection = base_p * uLightingDirection;

					// normal = normalMap;
					directionalLightWeighting = max(dot(normalMap.rgb, lightDirection), 0.0);
				}else{
					directionalLightWeighting = max(dot(normal, lightDirection), 0.0);
				}

				lightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;

				//************LUZ PUNTUAL****************
				float directionalPointLightWeighting;
				for(int i = 0; i < 10; i++){
					float distancia = distance(vPosition.xyz, uPointLightingLocation[i]);
					// if(distancia < 100.0){
					vec3 lightDirection = normalize(uPointLightingLocation[i] - vPosition.xyz);

					if (uUseNormalMap){
						vec4 normalMap = texture2D(uSamplerMap, vec2(vTextureCoord.s, vTextureCoord.t));
						normalMap = normalMap * 2.0 - vec4(1.0, 1.0, 1.0, 1.0);

						vec3 binormal = normalize(cross(normal, tangent));
						mat3 base_p = transpose(mat3(tangent, binormal, normal));
						lightDirection = base_p * lightDirection;
						// normal = normalMap;
						directionalPointLightWeighting = max(dot(normalMap.rgb, lightDirection), 0.0);
					}else{
						directionalPointLightWeighting = max(dot(normalize(normal), lightDirection), 0.0);
					}

					directionalPointLightWeighting *= 2.0/distancia;
					lightWeighting += uPointLightingColor * directionalPointLightWeighting;
				}
			}

			vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
			gl_FragColor = vec4(textureColor.rgb * lightWeighting, textureColor.a);
			//gl_FragColor = vec4(transformedNormal.rgb, 1.0);
			 //gl_FragColor = vec4(vVertexNormal.rgb*2.0-1.0, 1.0);
		}
	</script>

	<!-- Vertex shader para texturas EDIFICIOS -->
	<script id="shader-texture-edif-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			uniform vec3 uAmbientColor;

		    uniform vec3 uLightingDirection;
		    uniform vec3 uDirectionalColor;

		    uniform bool uUseLighting;

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			varying vec3 vVertexNormal;

			uniform float uAltura;

			void main(void) {
					// vec3 aux = aVertexPosition;
					// aux.y *= uAltura; //probar en y sino
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vTextureCoord = aTextureCoord;
					vVertexNormal = aVertexNormal;

					vTextureCoord.y *= uAltura;

					if (!uUseLighting) {
			            vLightWeighting = vec3(1.0, 1.0, 1.0);
			        } else {
			            vec3 transformedNormal = uNMatrix * aVertexNormal;
									transformedNormal = normalize(transformedNormal);
			            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
			            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
			        }
			}

	</script>

	<!--Fragment shader Texturas EDIFICIOS-->
	<script id="shader-texture-edif-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	varying vec3 vLightWeighting;
	varying vec3 vVertexNormal;

	uniform float uAlturaPB;
	uniform float uAlturaPisos;
	uniform sampler2D uSamplerPB;
	uniform sampler2D uSamplerPisos;

	void main(void) {
		vec2 uv = vTextureCoord;
		// vec4 textureColor;
		//Agregar if de acuerdo a la textura que uso
		if(vTextureCoord.y <= uAlturaPB){
			uv.y /= uAlturaPB;
			// uv.x /= 0.25 / uAlturaPB;
			vec4 textureColor = texture2D(uSamplerPB, uv);
			gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
			// gl_FragColor = vec4(vVertexNormal.rgb, 1.0);
		}else{
			uv.y -= uAlturaPB;
			uv.y /= uAlturaPisos;
			vec4 textureColor = texture2D(uSamplerPisos, uv);
			gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
			// gl_FragColor = vec4(vVertexNormal.rgb, 1.0);
		}

		// gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
	}
	</script>

	<!-- Vertex shader para texturas CALLES -->
	<script id="shader-texture-calle-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			uniform vec3 uAmbientColor;

		    uniform vec3 uLightingDirection;
		    uniform vec3 uDirectionalColor;

		    uniform bool uUseLighting;

			varying vec2 vTextureCoord;
			varying vec3 vLightWeighting;
			varying vec3 vVertexNormal;

			uniform float uAltura;

			void main(void) {
					// vec3 aux = aVertexPosition;
					// aux.y *= uAltura; //probar en y sino
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vTextureCoord = aTextureCoord;
					// vTextureCoord.y *= uAltura;
					vVertexNormal = aVertexNormal;

					if (!uUseLighting) {
			            vLightWeighting = vec3(0.8, 0.7, 0.4);
			        } else {
			            vec3 transformedNormal = uNMatrix * aVertexNormal;
									transformedNormal = normalize(transformedNormal);
			            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
			            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
			        }
			}

	</script>

	<!--Fragment shader Texturas CALLES-->
	<script id="shader-texture-calle-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	varying vec3 vLightWeighting;
	varying vec3 vVertexNormal;

	uniform float uFinManzana;
	uniform float uFinCruce;
	uniform sampler2D uSamplerCalle;
	uniform sampler2D uSamplerCruce;

	void main(void) {
		vec2 uv = vTextureCoord;
		float k = 1.0;
		int listorti = 0;
		for(int i = 0; i >= 0; i++){
			if(vTextureCoord.y < (uFinManzana * k + uFinCruce * (k - 1.0))){
				listorti = 1;
				uv.y -= (uFinManzana + uFinCruce) * (k - 1.0)/* - uFinCruce/6.0*/;
				uv.y /= uFinManzana;
				vec4 textureColor = texture2D(uSamplerCalle, uv);
				gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
				// gl_FragColor = vec4(vVertexNormal.rgb, 1.0);
			}else if(vTextureCoord.y < ((uFinManzana + uFinCruce) * k)){
				listorti = 1;
				uv.y -= ((uFinManzana * k) + uFinCruce * (k - 1.0));
				uv.y /= uFinCruce;
				vec4 textureColor = texture2D(uSamplerCruce, uv);
				gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
				// gl_FragColor = vec4(vVertexNormal.rgb, 1.0);
			}
			k += 1.0;
			if(listorti == 1)
				break;
		}
	}
	</script>

	<!-- Vertex shader para el canvas de la curva -->
	<script id="shader-canvas-curva" type="x-shader/x-vertex">
		// Los atributos son caracter�sticas propias de cada vertice.
		attribute vec3 aVertexPosition;
		// attribute vec3 aVertexColor;

		// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada
		// v�rtice del pol�gono al cual pertenecen.
		varying highp vec4 vColor;

		void main(void) {
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColor = vec4(0.0, 0.0, 0.0, 1.0);
				gl_PointSize = 5.0;
		}
	</script>

	<!-- Fragment shader para el canvas de la curva -->
	<script id="shader-fs-canvas-curva" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	</script>

	<script>
			var gl = null,
					canvas = null,
					glProgram = null,
					fragmentShader = null,
					vertexShader = null,
					t = 0.0;
					my_grid = null;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			var modelMatrix = mat4.create();

			 // SHADERS FUNCTION
			function getShader(gl, id) {
					var shaderScript, src, currentChild, shader;

					// Obtenemos el elemento <script> que contiene el c�digo fuente del shader.
					shaderScript = document.getElementById(id);
					if (!shaderScript) {
							return null;
					}

					// Extraemos el contenido de texto del <script>.
					src = "";
					currentChild = shaderScript.firstChild;
					while(currentChild) {
							if (currentChild.nodeType == currentChild.TEXT_NODE) {
									src += currentChild.textContent;
							}
							currentChild = currentChild.nextSibling;
					}

					// Creamos un shader WebGL seg�n el atributo type del <script>.
					if (shaderScript.type == "x-shader/x-fragment") {
							shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
							shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
							return null;
					}

					// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
					gl.shaderSource(shader, src);

					// Compilamos el shader.
					gl.compileShader(shader);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert("An error occurred compiling the shaders: " +
									gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
			}





			//
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////


			function initWebGL()
			{
					canvas = document.getElementById("my-canvas");
					try{
							gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
					}catch(e){
					}

					if(gl)
					{
							setupWebGL();
							initShaders();
							loadTextures();
							setupBuffers();

							canvas.onmousedown = handleMouseDown;
        			document.onmouseup = handleMouseUp;
        			document.onmousemove = handleMouseMove;
        			document.onkeydown = handleKeyDownOrb;

							setInterval(drawScene, 10);
					}else{
							alert("Error: Your browser does not appear to support WebGL.");
					}
			}

			function setupWebGL()
			{
					//set the clear color
					gl.clearColor(0.7, 0.7, 0.9, 1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);
					gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

					gl.viewport(0, 0, canvas.width, canvas.height);
			}

			function initShaders()
			{
				// Obtenemos los shaders ya compilados
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				// Creamos un programa de shaders de WebGL.
				glProgram = gl.createProgram();

				// Asociamos cada shader compilado al programa.
				gl.attachShader(glProgram, vertexShader);
				gl.attachShader(glProgram, fragmentShader);

				// Linkeamos los shaders para generar el programa ejecutable.
				gl.linkProgram(glProgram);

				// Chequeamos y reportamos si hubo alg�n error.
				if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
					alert("Unable to initialize the shader program: " +
								gl.getProgramInfoLog(glProgram));
					return null;
				}

				// Depende del tipo de objeto, el programa que uso
				gl.useProgram(glProgram);

				//SHADERS DE TEXTURAS
				var fragmentShaderTexturedObj = getShader(gl, "shader-texture-fs");
			    var vertexShaderTexturedObj = getShader(gl, "shader-texture-vs");

			    shaderProgramTexturedObject = gl.createProgram();
			    gl.attachShader(shaderProgramTexturedObject, vertexShaderTexturedObj);
			    gl.attachShader(shaderProgramTexturedObject, fragmentShaderTexturedObj);
			    gl.linkProgram(shaderProgramTexturedObject);

			    if (!gl.getProgramParameter(shaderProgramTexturedObject, gl.LINK_STATUS)) {
			        alert("Could not initialise shaders");
			    }

			    gl.useProgram(shaderProgramTexturedObject);

			    shaderProgramTexturedObject.vertexPositionAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexPosition");
			    gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexPositionAttribute);

			    shaderProgramTexturedObject.textureCoordAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aTextureCoord");
			    gl.enableVertexAttribArray(shaderProgramTexturedObject.textureCoordAttribute);

			    shaderProgramTexturedObject.vertexNormalAttribute = gl.getAttribLocation(shaderProgramTexturedObject, "aVertexNormal");
       			gl.enableVertexAttribArray(shaderProgramTexturedObject.vertexNormalAttribute);

		        shaderProgramTexturedObject.pMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPMatrix");
		        shaderProgramTexturedObject.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uMVMatrix");
		        shaderProgramTexturedObject.nMatrixUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uNMatrix");
		        shaderProgramTexturedObject.samplerUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uSampler");
		        shaderProgramTexturedObject.useLightingUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uUseLighting");
						//shaderProgramTexturedObject.useNormalMap = gl.getUniformLocation(shaderProgramTexturedObject, "uUseNormalMap");
		        shaderProgramTexturedObject.ambientColorUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uAmbientColor");
		        shaderProgramTexturedObject.lightingDirectionUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uLightingDirection");
		        shaderProgramTexturedObject.directionalColorUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uDirectionalColor");
		        shaderProgramTexturedObject.pointLightingLocationUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPointLightingLocation");
       	 		shaderProgramTexturedObject.pointLightingColorUniform = gl.getUniformLocation(shaderProgramTexturedObject, "uPointLightingColor");

       	 		//SHADER NORMAL MAP
       	 		var fragmentShaderNormalMap = getShader(gl, "shader-normal-map-fs");
				var vertexShaderNormalMap = getShader(gl, "shader-normal-map-vs");

				// Creamos un programa de shaders de WebGL.
				shaderProgramNormalMap = gl.createProgram();

				// Asociamos cada shader compilado al programa.
				gl.attachShader(shaderProgramNormalMap, vertexShaderNormalMap);
				gl.attachShader(shaderProgramNormalMap, fragmentShaderNormalMap);

				// Linkeamos los shaders para generar el programa ejecutable.
				gl.linkProgram(shaderProgramNormalMap);

				// Chequeamos y reportamos si hubo alg�n error.
				if (!gl.getProgramParameter(shaderProgramNormalMap, gl.LINK_STATUS)) {
					alert("Unable to initialize the shader program: " +
								gl.getProgramInfoLog(shaderProgramNormalMap));
					return null;
				}

				gl.useProgram(shaderProgramNormalMap);

			    shaderProgramNormalMap.vertexPositionAttribute = gl.getAttribLocation(shaderProgramNormalMap, "aVertexPosition");
			    gl.enableVertexAttribArray(shaderProgramNormalMap.vertexPositionAttribute);

			    shaderProgramNormalMap.textureCoordAttribute = gl.getAttribLocation(shaderProgramNormalMap, "aTextureCoord");
			    gl.enableVertexAttribArray(shaderProgramNormalMap.textureCoordAttribute);

			    shaderProgramNormalMap.vertexNormalAttribute = gl.getAttribLocation(shaderProgramNormalMap, "aVertexNormal");
       			gl.enableVertexAttribArray(shaderProgramNormalMap.vertexNormalAttribute);

       			// shaderProgramNormalMap.vertexTangentAttribute = gl.getAttribLocation(shaderProgramNormalMap, "aVertexTangent");
       			// gl.enableVertexAttribArray(shaderProgramNormalMap.vertexTangentAttribute);

		        shaderProgramNormalMap.pMatrixUniform = gl.getUniformLocation(shaderProgramNormalMap, "uPMatrix");
		        shaderProgramNormalMap.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramNormalMap, "uMVMatrix");
		        shaderProgramNormalMap.nMatrixUniform = gl.getUniformLocation(shaderProgramNormalMap, "uNMatrix");
		        shaderProgramNormalMap.samplerUniform = gl.getUniformLocation(shaderProgramNormalMap, "uSampler");
		        shaderProgramNormalMap.samplerNormalMap = gl.getUniformLocation(shaderProgramNormalMap, "uSamplerMap");
		        shaderProgramNormalMap.useLightingUniform = gl.getUniformLocation(shaderProgramNormalMap, "uUseLighting");
						shaderProgramNormalMap.useNormalMap = gl.getUniformLocation(shaderProgramNormalMap, "uUseNormalMap");
		        shaderProgramNormalMap.ambientColorUniform = gl.getUniformLocation(shaderProgramNormalMap, "uAmbientColor");
		        shaderProgramNormalMap.lightingDirectionUniform = gl.getUniformLocation(shaderProgramNormalMap, "uLightingDirection");
		        shaderProgramNormalMap.directionalColorUniform = gl.getUniformLocation(shaderProgramNormalMap, "uDirectionalColor");
		        shaderProgramNormalMap.pointLightingLocationUniform = gl.getUniformLocation(shaderProgramNormalMap, "uPointLightingLocation");
       	 		shaderProgramNormalMap.pointLightingColorUniform = gl.getUniformLocation(shaderProgramNormalMap, "uPointLightingColor");


		        //SHADERS DE TEXTURAS EDIFICIOS
				var fragmentShaderEdificio = getShader(gl, "shader-texture-edif-fs");
		        var vertexShaderEdificio = getShader(gl, "shader-texture-edif-vs");

		        shaderProgramEdificio= gl.createProgram();
		        gl.attachShader(shaderProgramEdificio, vertexShaderEdificio);
		        gl.attachShader(shaderProgramEdificio, fragmentShaderEdificio);
		        gl.linkProgram(shaderProgramEdificio);

		        if (!gl.getProgramParameter(shaderProgramEdificio, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }

		        gl.useProgram(shaderProgramEdificio);

		        shaderProgramEdificio.vertexPositionAttribute = gl.getAttribLocation(shaderProgramEdificio, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgramEdificio.vertexPositionAttribute);

		        shaderProgramEdificio.textureCoordAttribute = gl.getAttribLocation(shaderProgramEdificio, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgramEdificio.textureCoordAttribute);

		        shaderProgramEdificio.vertexNormalAttribute = gl.getAttribLocation(shaderProgramEdificio, "aVertexNormal");
       			gl.enableVertexAttribArray(shaderProgramEdificio.vertexNormalAttribute);

		        shaderProgramEdificio.pMatrixUniform = gl.getUniformLocation(shaderProgramEdificio, "uPMatrix");
		        shaderProgramEdificio.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramEdificio, "uMVMatrix");
		        shaderProgramEdificio.nMatrixUniform = gl.getUniformLocation(shaderProgramEdificio, "uNMatrix");
		        shaderProgramEdificio.samplerPB = gl.getUniformLocation(shaderProgramEdificio, "uSamplerPB");
		        shaderProgramEdificio.samplerPisos = gl.getUniformLocation(shaderProgramEdificio, "uSamplerPisos");
		        shaderProgramEdificio.Altura = gl.getUniformLocation(shaderProgramEdificio, "uAltura");
		        shaderProgramEdificio.AlturaPB = gl.getUniformLocation(shaderProgramEdificio, "uAlturaPB");
		        shaderProgramEdificio.AlturaPisos = gl.getUniformLocation(shaderProgramEdificio, "uAlturaPisos");
		        shaderProgramEdificio.useLightingUniform = gl.getUniformLocation(shaderProgramEdificio, "uUseLighting");
		        shaderProgramEdificio.ambientColorUniform = gl.getUniformLocation(shaderProgramEdificio, "uAmbientColor");
		        shaderProgramEdificio.lightingDirectionUniform = gl.getUniformLocation(shaderProgramEdificio, "uLightingDirection");
		        shaderProgramEdificio.directionalColorUniform = gl.getUniformLocation(shaderProgramEdificio, "uDirectionalColor");

		        //SHADERS DE TEXTURAS CALLE
				var fragmentShaderCalle = getShader(gl, "shader-texture-calle-fs");
		        var vertexShaderCalle = getShader(gl, "shader-texture-calle-vs");

		        shaderProgramCalle = gl.createProgram();
		        gl.attachShader(shaderProgramCalle, vertexShaderCalle);
		        gl.attachShader(shaderProgramCalle, fragmentShaderCalle);
		        gl.linkProgram(shaderProgramCalle);

		        if (!gl.getProgramParameter(shaderProgramCalle, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }

		        gl.useProgram(shaderProgramCalle);

		        shaderProgramCalle.vertexPositionAttribute = gl.getAttribLocation(shaderProgramCalle, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgramCalle.vertexPositionAttribute);

		        shaderProgramCalle.textureCoordAttribute = gl.getAttribLocation(shaderProgramCalle, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgramCalle.textureCoordAttribute);

		        shaderProgramCalle.vertexNormalAttribute = gl.getAttribLocation(shaderProgramCalle, "aVertexNormal");
       			gl.enableVertexAttribArray(shaderProgramCalle.vertexNormalAttribute);


		        shaderProgramCalle.pMatrixUniform = gl.getUniformLocation(shaderProgramCalle, "uPMatrix");
		        shaderProgramCalle.ModelViewMatrixUniform = gl.getUniformLocation(shaderProgramCalle, "uMVMatrix");
		        shaderProgramCalle.nMatrixUniform = gl.getUniformLocation(shaderProgramCalle, "uNMatrix");
			        shaderProgramCalle.useLightingUniform = gl.getUniformLocation(shaderProgramCalle, "uUseLighting");
		        shaderProgramCalle.ambientColorUniform = gl.getUniformLocation(shaderProgramCalle, "uAmbientColor");
		        shaderProgramCalle.lightingDirectionUniform = gl.getUniformLocation(shaderProgramCalle, "uLightingDirection");
		        shaderProgramCalle.directionalColorUniform = gl.getUniformLocation(shaderProgramCalle, "uDirectionalColor");
		        shaderProgramCalle.samplerCalle = gl.getUniformLocation(shaderProgramCalle, "uSamplerCalle");
		        shaderProgramCalle.samplerCruce = gl.getUniformLocation(shaderProgramCalle, "uSamplerCruce");
		        shaderProgramCalle.largo = gl.getUniformLocation(shaderProgramCalle, "uAltura");
		        shaderProgramCalle.finManzana = gl.getUniformLocation(shaderProgramCalle, "uFinManzana");
		        shaderProgramCalle.finCruce = gl.getUniformLocation(shaderProgramCalle, "uFinCruce");

				gl.useProgram(glProgram);
			}

			function makeShader(src, type)
			{
					//compile the vertex shader
					var shader = gl.createShader(type);
					gl.shaderSource(shader, src);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
							alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
					}
					return shader;
			}

			var v_texturas_pisos = [];
			var v_texturas_PB = [];

			function loadTextures(){
				v_texturas_pisos.push({nombre:"Texturas/ed1_pisos.jpg", x:512, y:512});
				v_texturas_pisos.push({nombre:"Texturas/ed2_pisos.jpg", x:512, y:512});
				v_texturas_pisos.push({nombre:"Texturas/ed3_pisos.jpg", x:256, y:512});
				v_texturas_pisos.push({nombre:"Texturas/ed4_pisos.jpg", x:512, y:512});
				v_texturas_pisos.push({nombre:"Texturas/ed5_pisos.jpg", x: 256, y: 512});
				v_texturas_pisos.push({nombre: "Texturas/ed6_fachada.jpg", x: 256, y:512});
				v_texturas_pisos.push({nombre:"Texturas/ed7_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed8_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed9_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed10_pisos.jpg", x: 256, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed11_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed12_pisos.jpg", x: 256, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed13_pisos.jpg", x: 256, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed14_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed15_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed16_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed17_pisos.jpg", x: 512, y: 512});
				v_texturas_pisos.push({nombre:"Texturas/ed18_pisos.jpg", x: 512, y: 256});
				v_texturas_pisos.push({nombre:"Texturas/ed19_pisos.jpg", x: 512, y: 512});
				v_texturas_PB.push({nombre:"Texturas/ed1_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed2_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed3_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed4_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed5_pb.jpg", x: 128, y: 128});
				v_texturas_PB.push({nombre:"Texturas/ed6_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed7_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed8_pb.jpg", x: 256, y: 128});
				v_texturas_PB.push({nombre:"Texturas/ed9_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed10_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed11_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed12_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed13_pb.jpg", x: 256, y: 128});
				v_texturas_PB.push({nombre:"Texturas/ed14_pb.jpg", x: 256, y: 128});
				v_texturas_PB.push({nombre:"Texturas/ed15_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed16_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed17_pb.jpg", x: 256, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed18_pb.jpg", x: 128, y: 64});
				v_texturas_PB.push({nombre:"Texturas/ed19_pb.jpg", x: 128, y: 128});
			}

			this.handleLoadedTexture = function(texture, repeat){
		        gl.bindTexture(gl.TEXTURE_2D, texture);
		        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		        if(!repeat){
							gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			    	}else{
			    		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
			    	}

		        gl.bindTexture(gl.TEXTURE_2D, null);
			}

			var comienzo_autopista = [];

			function setupBuffers(){
					var puntos = [];
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 20.0, 0.0]);
					// puntos.push([40.0, 0.0, 0.0]);
					// puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);

					camino = new curvaBspline3();
					camino.create(puntos);
					camino.setupWebGLBuffers();

/*					calle = new Calle();
					calle.create_perfil(1.0, 0.5);
					// calle.create_calle_escena(35.0, [0.0, 0.0, 35.0], 5.0);
					calle.create(camino, true);
					// calle.initTexture("Texturas/tramo-dobleamarilla.jpg");
					calle.initTexture("Texturas/autopista.jpg");
					// calle.initTexture("Texturas/cruce.jpg");
					calle.setupWebGLBuffers();
					// calle.debug_shader();*/


/*					edif = new Edificio();
					edif.create(10, 20, 10, [0, 0, 0], [0, 0, 0], 350.0);
					// edif.initTexture("ed12_pb.jpg");
					// edif.initTexture("ed1_pisos.jpg");
					edif.setupWebGLBuffers();*/

					escena = new Escena();
					escena.initTextures();

					//Cant manzanas, lado manzana, ancho calle
					escena.create_manzanas(6.0, 5.0, 1.0);
					escena.ubicar_autopista(puntos, 20, 10);
					escena.create_calles();
					escena.create_mapa();
					escena.create_autos();

					escena.setupWebGLBuffers();

					comienzo_autopista = escena.autopista.get_comienzo();

					vec3.multiply(comienzo_autopista, comienzo_autopista, [1, -1, 1]);
					vec3.add(comienzo_autopista, comienzo_autopista, [0, -6, 0]);
					free_camera_au.pos = comienzo_autopista;
			}

		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

			//Para manejar los eventos del mouse
		    var mouseDown = false;
		    var lastMouseX = null;
		    var lastMouseY = null;
		    var lastMouseX2 = null;
		    var lastMouseY2 = null;

		    var escenaRotationMatrix = mat4.create();
		    mat4.identity(escenaRotationMatrix);
		    var zoomMatrix = mat4.create();
		    mat4.identity(zoomMatrix);

		    var cameraMatrixAu = mat4.create();
		    mat4.identity(cameraMatrixAu);
		    var rotationMatrixAu = mat4.create();
		    mat4.identity(rotationMatrixAu);
		    var cameraMatrixSt = mat4.create();
		    mat4.identity(cameraMatrixSt);
		    var rotationMatrixSt = mat4.create();
		    mat4.identity(rotationMatrixSt);

		    var free_camera_au = {
		    	pos: [0.0, 0.0, 0.0],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2
		    }
		    var free_camera_st = {
		    	pos: [0.0, -1.0, -17.5],
		    	theta: Math.PI/2,
		    	phi: Math.PI/2
		    }

		    var cant_C = 0;

		    function handleMouseDown(event) {
		        mouseDown = true;
		        lastMouseX = event.clientX;
		        lastMouseY = event.clientY;
		        lastMouseX2 = event.clientX;
		        lastMouseY2 = event.clientY;
		    }


		    function handleMouseUp(event) {
		        mouseDown = false;
		    }

	        function handleKeyDownFreeStreet(event){
	        	//Uso coordenadas esfericas
	        	switch(event.keyCode){
	        		case 87:{ // 87 es la "w"

	        			//Modifico ambas coordenadas pq se tiene que mover en el sentido en el
	        			//que mira
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 83:{ //83 es "s"
						handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
						handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 65:{ // 65 es "a"
	        			handleKeyDownFreeStreet.camera.pos[2] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] += 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 68:{ // 68 es "d"
	        			handleKeyDownFreeStreet.camera.pos[2] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.sin(handleKeyDownFreeStreet.camera.phi);
	        			handleKeyDownFreeStreet.camera.pos[0] -= 1 * Math.sin(handleKeyDownFreeStreet.camera.theta) * Math.cos(handleKeyDownFreeStreet.camera.phi);
	        			break;
	        		}
	        		case 81:{
	        			handleKeyDownFreeStreet.camera.pos[1] -= 1;
	        			break;
	        		}
	        		case 69:{
	        			handleKeyDownFreeStreet.camera.pos[1] += 1;
	        			break;
	        		}
	        		case 67:
	        			handleCams();
		    			break;
	        	}
	        	actualizar_CameraMatrix(handleKeyDownFreeStreet.camera, handleKeyDownFreeStreet.mat, handleKeyDownFreeStreet.rot);
	        }

	        function handleMouseMoveFreeStreet(event){
	        	if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX2;
		        var deltaY = newY - lastMouseY2;

				handleMouseMoveFreeStreet.camera.phi += deltaX * 0.01;
				handleMouseMoveFreeStreet.camera.theta += deltaY * 0.01;

				if(handleMouseMoveFreeStreet.camera.theta > Math.PI)
					handleMouseMoveFreeStreet.camera.theta = Math.PI;

				if(handleMouseMoveFreeStreet.camera.theta < 0)
					handleMouseMoveFreeStreet.camera.theta = 0;

		        lastMouseX2 = newX;
		        lastMouseY2 = newY;

		        actualizar_CameraMatrix(handleMouseMoveFreeStreet.camera, handleMouseMoveFreeStreet.mat, handleMouseMoveFreeStreet.rot);
	        }

		    function handleMouseMove(event) {
		        if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX
		        var newRotationMatrix = mat4.create();
		        mat4.identity(newRotationMatrix);
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

		        var deltaY = newY - lastMouseY;
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

		        mat4.multiply(escenaRotationMatrix, newRotationMatrix, escenaRotationMatrix);

		        lastMouseX = newX
		        lastMouseY = newY;
		    }

		    function handleKeyDownOrb(event) {
		    	switch(event.keyCode){
		    		case 171: //+
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, 10.0]);
		    			break;
		    		case 173: // -
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, -10.0]);
		    			break;
		    		case 67: // c
		    			handleCams();
		    			break;
		    	}
		    }

		    function actualizar_CameraMatrix(free_camera, cameraMatrix, rotationMatrix){
		    	mat4.identity(cameraMatrix);
		    	mat4.identity(rotationMatrix);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.theta - Math.PI/2, [1.0, 0.0, 0.0]);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.phi, [0.0, 1.0, 0.0]);

		    	mat4.multiply(rotationMatrix, cameraMatrix, rotationMatrix);

		    	mat4.translate(cameraMatrix, cameraMatrix, free_camera.pos);
		    }

		    function handleCams(){
		    	primero = 0;
	    		if(cant_C == 0){

	    			actualizar_CameraMatrix(free_camera_st, cameraMatrixSt, rotationMatrixSt);

	    			handleMouseMoveFreeStreet.camera = free_camera_st;
	    			handleKeyDownFreeStreet.camera = free_camera_st;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixSt;
	    			handleKeyDownFreeStreet.mat = cameraMatrixSt;
	    			handleMouseMoveFreeStreet.rot = rotationMatrixSt;
	    			handleKeyDownFreeStreet.rot = rotationMatrixSt;

	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;

	    			cant_C++;

	    		}else if(cant_C == 1){

	    			actualizar_CameraMatrix(free_camera_au, cameraMatrixAu, rotationMatrixAu);

	    			handleMouseMoveFreeStreet.camera = free_camera_au;
	    			handleKeyDownFreeStreet.camera = free_camera_au;
	    			handleMouseMoveFreeStreet.mat = cameraMatrixAu;
	    			handleKeyDownFreeStreet.mat = cameraMatrixAu;
	    			handleMouseMoveFreeStreet.rot = rotationMatrixAu;
	    			handleKeyDownFreeStreet.rot = rotationMatrixAu;

	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;
	    			cant_C++;
	    		}else if(cant_C == 2){
	    			document.onmousemove = handleMouseMove;
	    			document.onkeydown = handleKeyDownOrb;
	    			cant_C = 0;
	    		}
		    }

		    var primero = 1;

			function drawScene(){
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				// Preparamos una matriz de perspectiva.
				mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 200.0);
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

				// PARA SHADER TEXTURAS
				gl.useProgram(shaderProgramTexturedObject);
				gl.uniformMatrix4fv(shaderProgramTexturedObject.pMatrixUniform, false, pMatrix);
				//------------------------
				// PARA SHADER NORMAL MAP
				gl.useProgram(shaderProgramNormalMap);
				gl.uniformMatrix4fv(shaderProgramNormalMap.pMatrixUniform, false, pMatrix);
				//------------------------
				// PARA SHADER EDIFICIO
				gl.useProgram(shaderProgramEdificio);
				gl.uniformMatrix4fv(shaderProgramEdificio.pMatrixUniform, false, pMatrix);
				//------------------------
				// PARA SHADER CALLE
				gl.useProgram(shaderProgramCalle);
				gl.uniformMatrix4fv(shaderProgramCalle.pMatrixUniform, false, pMatrix);
				gl.useProgram(glProgram);
				//------------------------

				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
				// Preparamos una matriz de modelo+vista.
				mat4.identity(mvMatrix);
				mat4.identity(modelMatrix);

	      var lighting_direction = [0.0, -0.5, 0.3];

				if((cant_C == 0) || (primero == 1)){
					mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);
					// modelMatrix = mvMatrix;

					mat4.multiply(mvMatrix, mvMatrix, zoomMatrix);
					mat4.multiply(mvMatrix, mvMatrix, escenaRotationMatrix);

					//Traslado ancho y alto ciudad
					mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
					// mat4.translate(modelMatrix, mvMatrix, [-11.5, 0.0, -11.5]);

					vec3.transformMat4(lighting_direction, lighting_direction, escenaRotationMatrix);
				}else if(cant_C == 1){
					vec3.transformMat4(lighting_direction, lighting_direction, rotationMatrixSt);
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixSt);
				}else{
					vec3.transformMat4(lighting_direction, lighting_direction, rotationMatrixAu);
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrixAu);
				}

				var adjustedLD = vec3.create();
	            vec3.normalize(adjustedLD, lighting_direction);
	            vec3.scale(adjustedLD, adjustedLD, -1);

				// mat4.rotate(mvMatrix, mvMatrix, t, [1.0, 0.0, 0.0]);
				t = t + 0.1;

				gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

				//PARA SHADER TEXTURAS
				gl.useProgram(shaderProgramTexturedObject);
				gl.uniformMatrix4fv(shaderProgramTexturedObject.ModelViewMatrixUniform, false, mvMatrix);
	            gl.uniform3fv(shaderProgramTexturedObject.lightingDirectionUniform, adjustedLD);
	            gl.uniform3f(shaderProgramTexturedObject.ambientColorUniform, 0.2, 0.2, 0.2);
            	gl.uniform3f(shaderProgramTexturedObject.directionalColorUniform, 0.8, 0.7, 0.4);
				//--------------------------------
				//PARA SHADER NORMAL MAP
				gl.useProgram(shaderProgramNormalMap);
				gl.uniformMatrix4fv(shaderProgramNormalMap.ModelViewMatrixUniform, false, mvMatrix);
	            gl.uniform3fv(shaderProgramNormalMap.lightingDirectionUniform, adjustedLD);
	            gl.uniform3f(shaderProgramNormalMap.ambientColorUniform, 0.2, 0.2, 0.2);
            	gl.uniform3f(shaderProgramNormalMap.directionalColorUniform, 0.8, 0.7, 0.4);
				//--------------------------------
				//PARA SHADER EDIFICIO
				gl.useProgram(shaderProgramEdificio);
				gl.uniformMatrix4fv(shaderProgramEdificio.ModelViewMatrixUniform, false, mvMatrix);
				gl.uniform3fv(shaderProgramEdificio.lightingDirectionUniform, adjustedLD);
				gl.uniform3f(shaderProgramEdificio.ambientColorUniform, 0.2, 0.2, 0.2);
            	gl.uniform3f(shaderProgramEdificio.directionalColorUniform,  0.8, 0.7, 0.4);
				//---------------
				//PARA SHADER CALLE
				gl.useProgram(shaderProgramCalle);
				gl.uniformMatrix4fv(shaderProgramCalle.ModelViewMatrixUniform, false, mvMatrix);
				gl.uniform3fv(shaderProgramCalle.lightingDirectionUniform, adjustedLD);
				gl.uniform3f(shaderProgramCalle.ambientColorUniform, 0.2, 0.2, 0.2);
            	gl.uniform3f(shaderProgramCalle.directionalColorUniform,  0.8, 0.7, 0.4);
				gl.useProgram(glProgram);
				//---------------

				//cuadrado.draw();
				// camino.draw();
				// ruta.draw();
				// edif.tick(t);
				// edif.draw(mvMatrix);
				escena.tick(t);
				escena.draw(mvMatrix);
				// calle.drawCalle(mvMatrix, 35.0, 2.0, 5.0);
				// calle.draw(mvMatrix);

			}

			function main(){
				initWebGL();
				init_canvas_curva();
			}

	window.onload=main();
	</script>

</body>
</html>
