<!doctype html>
<html>
	<head>
	<title>CityGrid</title>

	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="edificio.js"></script>
	<script type="text/javascript" src="vertexGrid.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="Primitivas/supBarrido.js"></script>
	<script type="text/javascript" src="curvas.js"></script>
	<script type="text/javascript" src="autopista.js"></script>
	<script type="text/javascript" src="autopista_calle.js"></script>
	<script type="text/javascript" src="autopista_borde.js"></script>
	<script type="text/javascript" src="escena.js"></script>
	<script type="text/javascript" src="plano.js"></script>
	<script type="text/javascript" src="vereda.js"></script>
	<script type="text/javascript" src="plaza.js"></script>
	<script type="text/javascript" src="Primitivas/supFan.js"></script>
	<script type="text/javascript" src="pilarAutopista.js"></script>
	<script type="text/javascript" src="Primitivas/supRevolucion.js"></script>
	<script type="text/javascript" src="luminaria.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="manzana.js"></script>
	<script type="text/javascript" src="canvas_curva.js"></script>
	<script type="text/javascript" src="auto.js"></script>
	<script type="text/javascript" src="rueda.js"></script>
	<script type="text/javascript" src="carcasaAuto.js"></script>


	</head>

	<body>
	<center>

		<h1>CityGrid</h1>
		<h2>Sistemas Gr&aacute;ficos - 66.71</h2>
		<h3>Alumnos</h3>
		<h4>Primer Cuatrimestre 2017</h4>

		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<canvas id="second-canvas" width="100" height="100">
		Your browser does not support the HTML5 canvas element.
		</canvas>

		<button class="btn" onclick="click_regenerar()">Regenerar</button>

	</center>

	<script id="shader-vs" type="x-shader/x-vertex">
			// Los atributos son caracter�sticas propias de cada vertice.
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexColor;

			// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
			// Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			// Los varying son propiedades que toman valor para cada fragmento a partir
			// de interpolar linealmente entre los valores que se les asigna en cada
			// v�rtice del pol�gono al cual pertenecen.
			varying highp vec4 vColor;

			void main(void) {
					// gl_Position es una variable "built-in" de GLSL que es usada para
					// almacenar la posici�n resultante del fragmento.
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vColor = vec4(aVertexColor,1.0);
			}
	</script>

	<!--
	Fragment shader

	Cada pixel en un pol�gono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a
	cada pixel.
	-->
	<script id="shader-fs" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vColor;
	}
	</script>

	<!-- Vertex shader para el canvas de la curva -->
	<script id="shader-canvas-curva" type="x-shader/x-vertex">
		// Los atributos son caracter�sticas propias de cada vertice.
		attribute vec3 aVertexPosition;
		// attribute vec3 aVertexColor;

		// Los uniforms son caracter�sticas propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada
		// v�rtice del pol�gono al cual pertenecen.
		varying highp vec4 vColor;

		void main(void) {
				// gl_Position es una variable "built-in" de GLSL que es usada para
				// almacenar la posici�n resultante del fragmento.
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColor = vec4(0.0, 0.0, 0.0, 1.0);
				gl_PointSize = 5.0;
		}
	</script>

	<!-- Fragment shader para el canvas de la curva -->
	<script id="shader-fs-canvas-curva" type="x-shader/x-fragment">
	varying highp vec4 vColor;

	void main(void) {
		// gl_FragColor es una variable "built-in" de GLSL que es usada para
		// almacenar el color resultante del fragmento.
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	}
	</script>

	<script>
			var gl = null,
					canvas = null,
					glProgram = null,
					fragmentShader = null,
					vertexShader = null,
					t = 0.0;
					my_grid = null;

			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();


			 // SHADERS FUNCTION
			function getShader(gl, id) {
					var shaderScript, src, currentChild, shader;

					// Obtenemos el elemento <script> que contiene el c�digo fuente del shader.
					shaderScript = document.getElementById(id);
					if (!shaderScript) {
							return null;
					}

					// Extraemos el contenido de texto del <script>.
					src = "";
					currentChild = shaderScript.firstChild;
					while(currentChild) {
							if (currentChild.nodeType == currentChild.TEXT_NODE) {
									src += currentChild.textContent;
							}
							currentChild = currentChild.nextSibling;
					}

					// Creamos un shader WebGL seg�n el atributo type del <script>.
					if (shaderScript.type == "x-shader/x-fragment") {
							shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
							shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
							return null;
					}

					// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
					gl.shaderSource(shader, src);

					// Compilamos el shader.
					gl.compileShader(shader);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert("An error occurred compiling the shaders: " +
									gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
			}





			//
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////


			function initWebGL()
			{
					canvas = document.getElementById("my-canvas");
					try{
							gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
					}catch(e){
					}

					if(gl)
					{
							setupWebGL();
							initShaders();
							setupBuffers();

							canvas.onmousedown = handleMouseDown;
        					document.onmouseup = handleMouseUp;
        					document.onmousemove = handleMouseMove;
        					document.onkeydown = handleKeyDownOrb;

							setInterval(drawScene, 10);
					}else{
							alert("Error: Your browser does not appear to support WebGL.");
					}
			}

			function setupWebGL()
			{
					//set the clear color
					gl.clearColor(0.7, 0.7, 0.9, 1.0);
					gl.enable(gl.DEPTH_TEST);
					gl.depthFunc(gl.LEQUAL);
					gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

					gl.viewport(0, 0, canvas.width, canvas.height);
			}

			function initShaders()
			{
					// Obtenemos los shaders ya compilados
					var fragmentShader = getShader(gl, "shader-fs");
					var vertexShader = getShader(gl, "shader-vs");

					// Creamos un programa de shaders de WebGL.
					glProgram = gl.createProgram();

					// Asociamos cada shader compilado al programa.
					gl.attachShader(glProgram, vertexShader);
					gl.attachShader(glProgram, fragmentShader);

					// Linkeamos los shaders para generar el programa ejecutable.
					gl.linkProgram(glProgram);

					// Chequeamos y reportamos si hubo alg�n error.
					if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
						alert("Unable to initialize the shader program: " +
									gl.getProgramInfoLog(glProgram));
						return null;
					}

					// Le decimos a WebGL que de aqu� en adelante use el programa generado.
					gl.useProgram(glProgram);
			}

			function makeShader(src, type)
			{
					//compile the vertex shader
					var shader = gl.createShader(type);
					gl.shaderSource(shader, src);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
							alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
					}
					return shader;
			}

			var comienzo_autopista = [];

			function setupBuffers(){
/*					cuadrado = new Edificio();
					cuadrado.create(2,2,1.5);
					cuadrado.setupWebGLBuffers();*/
					var puntos = [];
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([0.0, 0.0, 0.0]);
					puntos.push([40.0, 20.0, 0.0]);
					// puntos.push([40.0, 0.0, 0.0]);
					// puntos.push([60.0, 0.0, 0.0]);
					puntos.push([60.0, 0.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);
					puntos.push([80.0, 40.0, 0.0]);

/*					camino = new curvaBspline3();
					camino.create(puntos);
					//camino.curva_prueba();
					camino.setupWebGLBuffers();

					ruta = new Autopista();
					ruta.create(camino, 10, 10);*/
					escena = new Escena();

					//Cant manzanas, lado manzana, ancho calle
					escena.create_manzanas(6.0, 5.0, 1.0);
					escena.ubicar_autopista(puntos, 10, 10);
					escena.create_calles();
					escena.create_mapa();
					escena.create_autos();
					// update_camera(escena.autopista.comienzo, escena.autopista.punto_medio);

					pilar = new PilarAutopista();
					pilar.create();
					pilar.scale(0.1,0.1,0.1);

/*					plaza = new Plaza();
					plaza.create(4.0, 0.5);
					plaza.setupWebGLBuffers();*/
			}

		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }

			//Para manejar los eventos del mouse
		    var mouseDown = false;
		    var lastMouseX = null;
		    var lastMouseY = null;
		    var lastMouseX2 = null;
		    var lastMouseY2 = null;

		    var escenaRotationMatrix = mat4.create();
		    mat4.identity(escenaRotationMatrix);
		    var zoomMatrix = mat4.create();
		    mat4.identity(zoomMatrix);
		    var cameraMatrix = mat4.create();
		    mat4.identity(cameraMatrix);
		    // var freeCameraMatrix = mat4.create();
		    var free_camera = {
		    	// eye_point:[0, 10, 0],
		    	// at_point:[1, 50, 10],
		    	// up_point:[0, 1, 0]
		    	pos: [0.0, -10.0, -20.0],
		    	theta: Math.PI/2,
		    	phi: 0
		    }

		    var cant_C = 0;
		    
		    function myLookAt(cameraPos, target, up) {
		    	var z = vec3.create();
		    	vec3.subtract(z, cameraPos, target);		    	
		    	vec3.normalize(z, z);
		    	var x = vec3.create();
		    	vec3.cross(x, up, z);
		    	var y = vec3.create();
		    	vec3.cross(y, z, x);

		    	return[x[0], x[1], x[2], 0,
		    		   y[0], y[1], y[2], 0,
		    		   z[0], z[1], z[2], 0,
		    		   cameraPos[0], cameraPos[1], cameraPos[2], 1];	
		    }

	        function update_camera(comienzo_autopista, punto_medio_autopista){
	        	var eye_point = vec3.create();
		        vec3.add(eye_point, comienzo_autopista, [0, 10, 0]);

			    var at_point = vec3.create();
			    vec3.subtract(at_point, eye_point, punto_medio_autopista);
			    // vec3.normalize(eye_point, eye_point);
		        // vec3.set(eye_point, 40, 75, -100);

		        // vec3.set(at_point, 0, 0, 0);
		        var up_point = vec3.create();
		        vec3.set(up_point, 0, 1, 0);

		        mat4.lookAt(cameraMatrix, comienzo_autopista, [1, 0, 0], up_point);
	        }

	        function handleKeyDownFreeStreet(event){
	        	console.log(event.keyCode);
	        	switch(event.keyCode){
	        		case 87:{ // 87 es la "w"
	        			// vec3.add(free_camera.eye_point, free_camera.eye_point, [1.0, 0.0, 0.0]);
	        			// vec3.add(free_camera.at_point, free_camera.at_point, [1.0, 0.0, 0.0]);

	        			// free_camera.pos[2] += 1 * Math.cos(free_camera.theta);
	        			//Modifico ambas coordenadas pq se tiene que mover en el sentido en el 
	        			//que mira
	        			free_camera.pos[2] += 1 * Math.sin(free_camera.theta) * Math.sin(free_camera.phi + Math.PI/2);
	        			free_camera.pos[0] += 1 * Math.sin(free_camera.theta) * Math.cos(free_camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 83:{ //83 es "s"
						// vec3.add(free_camera.eye_point, free_camera.eye_point, [-1.0, 0.0, 0.0]);
						// vec3.add(free_camera.at_point, free_camera.at_point, [-1.0, 0.0, 0.0]);
						free_camera.pos[2] -= 1 * Math.sin(free_camera.theta) * Math.sin(free_camera.phi + Math.PI/2);
						free_camera.pos[0] -= 1 * Math.sin(free_camera.theta) * Math.cos(free_camera.phi + Math.PI/2);
	        			break;
	        		}
	        		case 65:{ // 65 es "a"
	        			// vec3.add(free_camera.eye_point, free_camera.eye_point, [0.0, 0.0, -1.0]);
	        			// vec3.add(free_camera.at_point, free_camera.at_point, [0.0, 0.0, -1.0]);

	        			// free_camera.pos[2] += 1 * Math.cos(free_camera.theta);
	        			//Le sumo 90 pq tiene que moverse perpendicular a donde mira
	        			free_camera.pos[2] += 1 * Math.sin(free_camera.theta) * Math.sin(free_camera.phi);
	        			free_camera.pos[0] += 1 * Math.sin(free_camera.theta) * Math.cos(free_camera.phi);
	        			break;
	        		}
	        		case 68:{ // 68 es "d"
	        			// vec3.add(free_camera.eye_point, free_camera.eye_point, [0.0, 0.0, 1.0]);
	        			// vec3.add(free_camera.at_point, free_camera.at_point, [0.0, 0.0, 1.0]);

	        			// free_camera.pos[2] -= 1 * Math.cos(free_camera.theta);
	        			free_camera.pos[2] -= 1 * Math.sin(free_camera.theta) * Math.sin(free_camera.phi);
	        			free_camera.pos[0] -= 1 * Math.sin(free_camera.theta) * Math.cos(free_camera.phi);
	        			break;
	        		}
	        		case 67:
	        			handleCams();
		    			break;
	        	}
	        	// mat4.lookAt(cameraMatrix, free_camera.eye_point, free_camera.at_point, free_camera.up_point);
	        	// mat4.translate(cameraMatrix, cameraMatrix, free_camera.eye_point);
	        	// cameraMatrix =  myLookAt(free_camera.eye_point, free_camera.at_point, free_camera.up_point);

	        	actualizar_CameraMatrix();
	        }

	        function handleMouseMoveFreeStreet(event){
	        	if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX2;
		        var deltaY = newY - lastMouseY2;
		        // var newRotationMatrix = mat4.create();
		  //       mat4.identity(newRotationMatrix);
		  //       // mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
		  //       console.log("at point antes: ", free_camera.at_point);

		  //       vec3.rotateX(free_camera.at_point, free_camera.at_point, free_camera.eye_point, degToRad(deltaY / 10));

				// console.log("at point des: ", free_camera.at_point);
		        
		  //       // mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
		  //       vec3.rotateY(free_camera.at_point, free_camera.at_point, free_camera.eye_point, degToRad(deltaX / 10));

		  //       cameraMatrix = myLookAt(free_camera.eye_point, free_camera.at_point, free_camera.up_point);

		        // mat4.lookAt(cameraMatrix, free_camera.eye_point, free_camera.at_point, free_camera.up_point);
		        // var aux = vec3.create();
		        // vec3.negate(aux, free_camera.eye_point);
		        // mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
		        // mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
		        // mat4.translate(newRotationMatrix, newRotationMatrix, free_camera.eye_point);

				// mat4.multiply(cameraMatrix, newRotationMatrix, cameraMatrix);
				free_camera.phi += deltaX * 0.01;
				free_camera.theta += deltaY * 0.01;

				if(free_camera.theta > Math.PI)
					free_camera.theta = Math.PI;

				if(free_camera.theta < 0)
					free_camera.theta = 0;

		        lastMouseX2 = newX;
		        lastMouseY2 = newY;

		        actualizar_CameraMatrix();
	        }

		    function handleMouseDown(event) {
		        mouseDown = true;
		        lastMouseX = event.clientX;
		        lastMouseY = event.clientY;
		    }


		    function handleMouseUp(event) {
		        mouseDown = false;
		    }


		    function handleMouseMove(event) {
		        if (!mouseDown) {
		            return;
		        }
		        var newX = event.clientX;
		        var newY = event.clientY;

		        var deltaX = newX - lastMouseX
		        var newRotationMatrix = mat4.create();
		        mat4.identity(newRotationMatrix);
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

		        var deltaY = newY - lastMouseY;
		        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

		        mat4.multiply(escenaRotationMatrix, newRotationMatrix, escenaRotationMatrix);

		        lastMouseX = newX
		        lastMouseY = newY;
		    }

		    function handleKeyDownOrb(event) {
		    	switch(event.keyCode){
		    		case 171: //+
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, 10.0]);
		    			break;
		    		case 173: // -
		    			mat4.translate(zoomMatrix, zoomMatrix, [0.0, 0.0, -10.0]);
		    			break;
		    		case 67: // c
		    			handleCams();
		    			break;
		    	}
		    }

		    function actualizar_CameraMatrix(){
		    	var aux = vec3.create();
		    	mat4.identity(cameraMatrix);
		    	// mat4.translate(cameraMatrix, cameraMatrix, free_camera.pos);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.theta - Math.PI/2, [1.0, 0.0, 0.0]);
		    	mat4.rotate(cameraMatrix, cameraMatrix, free_camera.phi, [0.0, 1.0, 0.0]);
		    	
		    	mat4.translate(cameraMatrix, cameraMatrix, free_camera.pos);
		    	// vec3.negate(aux, free_camera.pos);
		    	// mat4.translate(cameraMatrix, cameraMatrix, aux);
		    }

		    function handleCams(){
		    	console.log("cant c: ", cant_C);
		    	primero = 0;
	    		if(cant_C == 0){
	    			// mat4.identity(cameraMatrix); 
    				document.onmousemove = handleMouseMove;
	    			document.onkeydown = handleKeyDownOrb;
	    			cant_C++;
	    		}else if(cant_C == 1){
	    			console.log("Camara libre");
	    			// var center = vec3.create();
	    			// vec3.add(center, free_camera.eye_point, free_camera.at_point);
	    			// mat4.lookAt(cameraMatrix, free_camera.eye_point, center, free_camera.up_point);
	    			// cameraMatrix = myLookAt(free_camera.eye_point, free_camera.at_point, free_camera.up_point);
					actualizar_CameraMatrix();
	    			
	    			document.onmousemove = handleMouseMoveFreeStreet;
	    			document.onkeydown = handleKeyDownFreeStreet;
	    			cant_C = 0;
	    		}/*else if(cant_C == 2){
	    			// mat4.identity(cameraMatrix);
	    			document.onmousemove = handleMouseMove;
	    			document.onkeydown = handleKeyDownOrb;
	    			cant_C = 0;
	    		}*/
		    }

		    var primero = 1;

			function drawScene(){
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
				// Preparamos una matriz de perspectiva.
				mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 200.0);
				gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

				var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
				// Preparamos una matriz de modelo+vista.
				mat4.identity(mvMatrix);
				// mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);

				if((cant_C == 1) || (primero == 1)){
					mat4.translate(mvMatrix, mvMatrix, [0.0, -10.0, -20.0]);
					mat4.multiply(mvMatrix, mvMatrix, zoomMatrix);
					mat4.multiply(mvMatrix, mvMatrix, escenaRotationMatrix);
					mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				}else{
					mat4.multiply(mvMatrix, mvMatrix, cameraMatrix);
					// mat4.invert(mvMatrix, cameraMatrix);
				}			
				
				//Traslado ancho y alto ciudad
				// mat4.translate(mvMatrix, mvMatrix, [-11.5, 0.0, -11.5]);
				// mat4.rotate(mvMatrix, mvMatrix, t, [1.0, 0.0, 0.0]);
				t = t + 0.1;

				gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

				//cuadrado.draw();
				// camino.draw();
				// ruta.draw();

				escena.tick(t);
				escena.draw(mvMatrix);

				// plaza.draw();
				// pilar.draw();

			}

			function main(){
				initWebGL();
				init_canvas_curva();
			}

	window.onload=main();
	</script>

</body>
</html>
